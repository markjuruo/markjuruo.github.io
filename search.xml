<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[旧事记 那些我玩过的游戏 2.2-2.3]]></title>
    <url>%2F2019%2F02%2F02%2Fjiu-shi-ji-games%2F</url>
    <content type="text"><![CDATA[在颓了一天以后忽然想了很多东西。特记。 2010我大概是幼儿园时第一次接触了电子游戏。那时候没有什么手机、电脑的。我和我三个表哥不知道哪里搞来的游戏卡，插在游戏机里面，然后连上家里的一台旧电视。像素不高，控制游戏的摇杆也算不上灵敏，但我们玩得开心。那时候我们就玩《魂斗罗》，两个人一起，我们轮着来。那时候我们玩并不为了从游戏里找乐子，就是四个人在一起，舒服。 2011小学一年级时，我拿到了我的第一个游戏机。说实话我并不怎么喜欢它，就是一些简单的 RPG 式互动。同样是在小学一年级时，我第一次玩到了《植物大战僵尸》（P.V.Z.），这算是我玩的第一个电脑单机游戏。 我相信这款游戏大多数和我年纪相仿的同学都玩过。我有次在学校里面哼起了这款游戏的一段配乐《Graze the Roof》（屋顶关卡），结果邻桌的同学也跟着唱了起来。这种同志般的情感令人振奋。我甚至之后还去学了《植物大战僵尸》的主题曲《Zombies on your lawn》。 20137K7K，4399 等在线小游戏网站蒸蒸日上，我记得我当时最喜欢玩的是《森林冰火人》《勇者之路精灵物语》。我玩的时候喜欢挑着无敌版的，打起来带感。那时候打游戏的目的已经逐渐转变为消遣，也就是为了单纯的娱乐罢了。 2015《生死狙击》等多人射击游戏纷纷上线，我约莫是在小学四年级时接触到了。那时候我觉得多人联机打有种说不出的快感，特别是能和别人交流着怎么进攻，怎么防守。 我第一次玩到了《红色警戒》这样一款单机的及时战略游戏。我急得我最喜欢用苏联，掌握石油开采，赚钱很快，基本都能打赢电脑。 电脑上不知道为什么有《极品飞车7》，我于是便尝试了一下。画质还好，游戏性很强，开氮气加速撞爆警车的感觉很刺激。 另外还试了一下《愤怒的小鸟》。 2016《王者荣耀》上线了。说实话，当时我对它一点不感兴趣。我当时觉得什么人会无聊到控制一个小人在一个狭窄的封闭的小空间里四处乱逛还要把对面的什么窝给掏了。我无法理解那种乐趣。 不过我还是去尝试了一下。在一个寒假里面我安装了这个游戏，结果连续打了三把都是赢的就卸载了，“实在没什么好打的。” 不过到现在，放假的时候，还是会安装个，和三个表哥联机玩个一两把。 2017《狼人杀》手游上线了。6月份，那时候快小学毕业了，（感觉）没啥压力，居然无聊到下载了一个来玩。那时候玩，就是很享受那种团队合作推理的快感。 《弄死火柴人（手游）》，我玩过的一款十分解压的游戏，大概就是用各种方式来折磨一个可怜的火柴人。 《瘟疫公司》，十分真实的生存经营游戏，我玩完之后就养成了勤洗手的好习惯。。。 2018-2019 开始吹*了。 《信息学奥赛》《NOIP》这一类高级游戏让我眼前一亮，说实话我很喜欢，不过难度对我来说蛮大的。 可惜的是我不肯放弃。一直在学校信奥社团里面呆着，，浪费了一个位置。。。 总结事实上我对游戏并不是十分感兴趣，到今天能让我觉得影响深刻的也就是《植物大战僵尸》和《愤怒的小鸟》两款游戏最初的版本。从配乐到游戏构建都深入人心。说实话《植物大战僵尸2》和《愤怒的小鸟2》我都不是很玩得起来，总觉得什么东西变了，或者说，它们都多了太多不该有的东西，例如联机功能和奇怪的广告。我并不热衷于此，但是它们的确带给了我很多影响。 我并不打算摒弃它们，但是时间会带着它们离开。可能没有告别，我也许会直接忘却罢了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旧事记 初二上 1.21-1.24]]></title>
    <url>%2F2019%2F01%2F24%2Fjiu-shi-ji-chu-er-shang-1-21-1-24%2F</url>
    <content type="text"><![CDATA[期末考试似乎还行，忍不住续写期中考试后写的《咸鱼》 我不知道要从哪一次失败开始写起。怕是太多罢了。我大概是从进初中开始才发觉了生活没有我想象的这么轻松。我是到了现在才知道成功这条路根本没有这么好走。我似乎是失去了很多，但我却常常不合时宜地感到知足，我似乎是习惯了，习惯了耀眼的是别人，灰暗的是自己。我的确感到痛苦，但是痛苦过后，又会把伤口掩盖起来，我把它藏起来，好像这样它就不会对我造成伤害，“我他妈的，再也受不了了啊。” 2018 年这一年，我从初一跨入初二。我自以为摆脱了初一的稚嫩，自以为能够“突飞猛进”。我欣喜若狂地参加了 2050 大会，也毫不顾忌地立下许多 Flag，我信心满满地参加了 NOIP 信奥比赛，然后灰头土脸地接受失败。 我似乎是在期中考试前，忽然翻到了《课堂内外》上刊登了我参加 2050 的内容，我忽然心很痛，因为那时我刚刚参加完 NOIP 初赛，也差不多知道自己只能止步于此了。那些我曾经说的豪言壮志，“真他妈可笑。” 我在期中考复习阶段爱上了《咸鱼》这首歌，因为我在我们班级 MV 中听到了它。我第一次听似乎是在小学三年级。我那时不过是觉得很好听。可我看到我们班的班级 MV 时，看到初一的我时，我哭了出来，尽管别人都是在欢呼着，在笑着。我忽然想起来初一的我是多么期待能在信奥上大方光彩，“我的梦想，就这么不值钱吗。” 终于，期中考似乎是有了一点小小的进步，至少，我有了一定的自信的资本。事实上我看到期中考成绩的时候，情绪十分激动，我打开音响，放《咸鱼》。然后让自己无拘束的哭出来。 这之后，我似乎变得聒噪起来。我开始静不下心来，我也不知道为什么。但事实上我根本不想知道，我甚至觉得这样挺好。 2019 年期末模拟考的成绩并不让人满意，我于是重新开始反思，我开始遏制住焦躁的情绪，对于期末考，“我嘴上说着不要，身体却很诚实。” 终于，我考出了对我来说十分优秀的成绩。不过我知道是超常发挥，毕竟我的语文 112 这种恶心的高分并不是想考就能考出来的。科学的 158 分也算是状态较好的发挥，但是我仍然是十分高兴，毕竟没有辜负之前的努力。今年，总算是可以过个好年了。 这里本来写了一些过分诚实的话，现在删去。见谅。。 抒情结束。 另：祝我新年快乐！祝 markjuruo 小博客常更！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用 Python 实现基于 UDP 协议的聊天工具？]]></title>
    <url>%2F2018%2F12%2F09%2Fru-he-yong-python-shi-xian-ji-yu-tcp-ip-xie-yi-de-liao-tian-gong-ju%2F</url>
    <content type="text"><![CDATA[前言最近刚自学的 Python ，有 C++ 的基础上手还算快。Python 的网络库使用十分简便，此文简单记录基于 UDP 协议的聊天程序编写过程。相比 TCP-IP 协议， 使用 UDP 协议写出的程序在我看来结构更加清晰，且也比较方便之后多线程的加入。 主要思路服务器端负责处理信息转发，将某个客户端发来的消息转发到别的客户端，以达到信息交换的功能，即简单的聊天功能客户端需要做到接收消息和发送消息，并且这两个进程必须是同时进行的。 尝鲜服务器下载客户端下载 效果图： 简单架构 基于 UDP 协议编写服务器端不得不说，使用 UDP 协议会比 TCP-IP 协议简洁很多，最核心的部分便是 recvfrom() 和 sendto() 。与 TCP-IP 协议下的 recv() 和 send() 不同，UDP 下能够更加明确的获取收到信息的内容和来源。以下便是一个简单的基于 UDP 协议的服务器模型。 1234567891011121314import socket # 引用网络库from sys import exit # 从 System 借一个 exit() 函数s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 声明对象 sHOST = '127.0.0.1' # 服务器 IP 地址PORT = 10888 # 服务器端口s.bind((HOST, PORT)) # 启动服务器while True: # 进入消息循环 (data, addr) = s.recvfrom(1024) # 接收消息 print("Recv-data", data.decode('utf-8')) # 将收到的消息转码并输出 s.sendto(data, addr) # 将消息发回 需要注意的是 HOST 里的值是需要改的。把它改成你自己这台电脑的 ip 地址（至于如何查询本机 IP 地址请自行百度，或者你可以在 cmd 中输入 ipconfig 找到 “IPv4地址” 一项） 不难看出，recvfrom() 函数获取的是一个元组，包含了数据和地址两个信息，因此我们使用 data,addr 将其保存。在输出时，data.decode(&#39;utf-8&#39;) 的操作与下面客户端 data.encode(&#39;utf-8&#39;) 的操作相对应。在信息传输的过程中，我们需要声明用哪一种编码进行传输和保存。 utf-8 是目前较为常用的包含汉字的编码。其他常见编码还有 unicode，ascii，utf-16 等。 而服务器接收到的消息是经过 encode(&#39;utf-8&#39;) 处理的，于是此时需要 decode(&#39;utf-8&#39;) 进行解码。 基于 UDP 协议编写客户端有服务器进行接收了，就必须得有客户端来发送。一下展示了一个简单的具有传输和接收信息功能的服务器。 123456789101112131415import socket # 引用网络库from sys import exit # 从 System 借一个 exit() 函数s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 声明对象 sHOST = '127.0.0.1' # 服务器 IP 地址PORT = 10888 # 服务器端口s.connect((HOST, PORT)) # 连接到服务器while True: # 进入消息循环 data = input("Input Data: ") # 输入待发送的数据 s.sendto(data.encode('utf-8'), (HOST,PORT)) # 发送到服务器 (data, addr) = s.recvfrom(1024) # 从服务器接收信息 print("Recv-Data: ", data.decode('utf-8')) # 输出接收到的信息 此处的 s.connect() 与服务器中的 s.bind() 略有不同，至于为什么我正在研究由此我们可以了解，sendto() 函数的两个参数含义：前一个是设置了编码格式的信息内容，后一个是一组元组，包含 HOST 和 PORT ，即需要发送到的主机的 IP 地址（一般用 IPv4 ）和端口号（注意端口号必须是数字类型）。不难看出，s.sendto() 是具有方向性的，说清楚发给谁，就只能谁接收到。同时可以发现，s.recvfrom(1024) 是不具有方向性的，只要是发到我的，不管是谁，我都接收。s.recvfrom() 是开放的，s.sendto() 要是开放的话可能会出事。 利用服务器作为中转站上面给出了一幅基本结构图，是为了简单叙述 socket 库中每个函数的作用。下面这张图是为了体现服务器的基本作用：中转交接。 从图中我们不难发现无论是你还是其它用户，一旦需要信息交换，就必须经过服务器。事实上，你可以选择不经过，但是为了让程序更有条理，我选择利用服务器作为中转站。 那么问题来了，如果要做到信息交换，就必然涉及到两台及以上的主机。此时，前面我们所写的服务器模型似乎无法完成交换任务，因为它只有接收的功能，那么该如何解决？ 以下服务器称为 server，客户端称为 client 我的思路是这样的：利用 python 的字典（dict）储存每一个加入到 server 的 client。然后在发送的时候，遍历整个 dict ，把所有储存的主机都发送一遍。（讲的什么乱七八糟的，直接上程序）至于不知道 Python 字典是什么，请自行学习：Python 字典(Dictionary) | 菜鸟教程 12345678910111213141516171819202122# server 2.0 实现信息交换import socket # 引用网络库from sys import exit # 从 System 借一个 exit() 函数s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 声明对象 sHOST = '127.0.0.1' # 服务器 IP 地址PORT = 10888 # 服务器端口s.bind((HOST, PORT)) # 启动服务器user = &#123;&#125; # 设置一个空的 dict while True: # 进入消息循环 (data, addr) = s.recvfrom(1024) # 接收到消息 if user.get(addr, False) == False: # 利用 get 函数来确定是否是新 client user[addr] = data.decode('utf-8') # 如果是的话，把它第一个发来的信息默认为用户名 print("IP(%s) NickName(%s) Join" % (addr, data.decode('utf-8'))) # 输出用户加入信息 print(addr," : ", data.decode('utf-8')) # 输出：谁发的，发了什么 for key, value in user.items(): # 遍历已经储存的 client s.sendto(data, key) # 向这些 client 传输某个用户发出的信息。 这串代码码风并不是很和谐，但是条理还算清晰。重点： 123if user.get(addr, False) == False: user[addr] = data print("IP(%s) NickName(%s) Join" % (addr, data.decode('utf-8'))) 首先 Python 中 dict 的 get 函数用法请自行学习。我在这里把 addr ，即用户的 IP 地址作为关键字，而它发送的第一条信息作为值。1if user.get(addr, False) == False: 这一句话便起到了去重的作用，如果该 addr 关键字已经被包含的话，就不再把它重复纳入 dict 中。但是如果原先没有这个关键字，那么需要把它加入到 dict 中。并且，以用户发的第一条信息作为该关键字的值，即用户名，相当于构成了一个 { IP 地址 : 用户名 } 的 dict。 客户端的程序基本不变，就是在进入消息循环之前（就是 while True: 之前）需要加上一段，提示用户输入用户名，并且作为第一条消息发出。即：12NickName = input("Please input your nick-name : ")s.sendto(NickName.encode('utf-8'), (HOST, PORT)) 另外，这里的最后一段代码也可以适当修改一下：12for key, value in user.items(): s.sendto(data, key) 改成：123for key, value in user.items(): if key != addr: s.sendto(data.encode('utf-8'), key) addr 就是这条信息的发出者，既然是他发出的，那他自己的客户端必定显示了他输入的内容，如果再显示一遍就显得累赘了。 如何实现多线程这一段我挣扎了很久，因为线程编程对于一个长期使用低版本 C++ 的孩子来说十分陌生。 在使用之前我们先得明确，为什么我们要用线程？ 在之前 “利用服务器作为中转站” 中我们编写了一个支持信息交换的程序，但是使用时我们不难发现，这个程序有一个很大的弊端：输发接收不同步，即只能发一条，接收一条，不发就接收不到。 遇到这个问题的时候我第一时间想到了利用缓冲区解决，以前用 C++ 写 《Tank War》 的时候不会多线程，就是每 5 ms 刷新一次缓冲区，检测是否输入字符，如果输入就执行相应的操作，否则程序按部就班的进行。但是用在这里肯定不现实，5 ms 可能连个 “f__k” 都打不完。 于是只好去简单学习下多线程，我利用的是这篇教程 ，简单明了，但是折腾了半天才应用到我的程序上来。 另外要讲的是，需要多线程的事实上仅有 client ，因为 client 需要同时做两件事：发送和接收，而服务器似乎没有这个负担，它仅需转发。 所以，我们聚焦到客户端来：12345678910111213141516171819202122232425262728293031323334import socketimport threading, time # 包含 threading（线程控制）和 time （时间控制）from sys import exits = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)HOST = '192.168.1.2'PORT = 10888s.connect((HOST, PORT))# 一下定义两个函数 RECV() 和 SEND()，分别进行收、发def RECV(): while True: (data, addr) = s.recvfrom(1024) print("HOST: ", data.decode('utf-8')) time.sleep(1) def SEND(): while True: data = input("") s.sendto(data.encode('utf-8'), (HOST, PORT)) time.sleep(1)t1 = threading.Thread(target=RECV) # 将 RECV() 放入线程 t1t2 = threading.Thread(target=SEND) # 将 SEND() 放入线程 t2t1.start() # 启动线程 t1t2.start() # 启动线程 t2t1.join()t2.join()# join所完成的工作就是线程同步# 即主线程任务结束之后，进入阻塞状态# 一直等待其他的子线程执行结束之后，主线程再终止 我们把 client 的两个任务：收、发打包成了两个函数，放入两个不同的进程中，再让这两个进程同步运行，就做到了收、发同时进行的目的。至于每个函数中出现的 time.sleep(1)，是推迟时间，相当于暂停一秒。如果不写上会出现一种很玄学错误，就是收发都变得不完整，可能你发的是 “1234567” ，server 接收到的却是 “12”；server 发来了 “kkksc03” ，结果 client只接收到了 “kkk”。time.sleep(1) 的操作就是为了让它有充足的时间完成自己的任务，慢下来，也许能做的更好，生活也豁然开朗。 至此，你已经完成了一个客户端的基本操作了。 让我知道你是谁注意，如果使用以上 client ，还有一点每种不足，那就是不论谁发来的信息，都是如下显示：123HOST: 123HOST: hello!HOST: ... 这样似乎并不是很友好。所以，为了让它成为一个合格的通讯工具，我们还要再进行一点小小的修改： 首先，找到 client 中的 RECV() 函数，把 print 中恼人的 &quot;HOST&quot; 删去：12345def RECV(): while True: (data, addr) = s.recvfrom(1024) print(=data.decode('utf-8')) time.sleep(1) 然后，找到 server 中的这一段：123for key, value in user.items(): if key != addr: s.sendto(data, key) 还记得我们之前建立的 user 字典是以 { IP 地址 : 用户名 } 的格式来储存的吗？我们现在手上有 addr ，想要知道其用户名，只要用 user[addr] 就可以获取了。然后，我们可以把用户名和其发出信息整合，如下：1234data = user[addr] + " : " + data.decode('utf-8') for key, value in user.items(): if key != addr: s.sendto(data.encode('utf-8'), key) OK，大功告成！再次运行，你就能看到每个人的用户名了！123老王: Hello!小明: Hi!小红: Have a nice day! 最后说一句写了这么多，你难道没发现什么问题吗？没错，我们在 server 和 client 的程序开头总有一段：12HOST = '127.0.0.1'PORT = 10888 那么问题来了，不论是针对 server 还是 client，在不同的电脑上打开，IP 地址（也就是其 HOST 的值）都是不同的。所以我们需要进行再一次修改：12HOST = input("Input Server IP address: ")PORT = 10888 把 server 和 client 都改成以上格式，便大功告成了。使用的时候只要查询一下本机（服务器） IP 地址，输入即可。 源码（不要脸的放上了版权信息） server 服务器123456789101112131415161718192021222324252627print("Hosted By markjuruo(Linzhihan)")print("To view more, please visit")print("https://github.com/markjuruo/Python-UDP-Chating\n")import socketfrom sys import exits = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)HOST = input("Please input IP address: ")PORT = 10888s.bind((HOST, PORT))user = &#123;&#125;while True: (data, addr) = s.recvfrom(1024) if user.get(addr, False) == False: user[addr] = data.decode('utf-8') print("IP(%s) NickName(%s) Join" % (addr, data.decode('utf-8'))) else: print(addr," : ", data.decode('utf-8')) data = user[addr] + " : " + data.decode('utf-8') for key, value in user.items(): if key != addr: s.sendto(data.encode('utf-8'), key) cilent 客户端1234567891011121314151617181920212223242526272829303132333435print("Hosted By markjuruo(Linzhihan)")print("To view more, please visit")print("https://github.com/markjuruo/Python-UDP-Chating\n")import socketimport threading, timefrom sys import exits = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)HOST = input("Please input IP address: ")PORT = 10888NickName = input("Please input your nick-name : ")s.sendto(NickName.encode('utf-8'), (HOST, PORT))def RECV(): while True: (data, addr) = s.recvfrom(1024) print(data.decode('utf-8')) time.sleep(1) def SEND(): while True: data = input("") s.sendto(data.encode('utf-8'), (HOST, PORT)) time.sleep(1)t1 = threading.Thread(target=RECV)t2 = threading.Thread(target=SEND)t1.start()t2.start()t1.join()t2.join()]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[经验] F12大法的正确打开方式]]></title>
    <url>%2F2018%2F11%2F22%2Fjing-yan-f12-da-fa-de-zheng-que-da-kai-fang-shi%2F</url>
    <content type="text"><![CDATA[前言F12 似乎越来越流行了。但凡是个会点 Information Technology 的犇犇都无时无刻享受着使用 F12 调教网页的快感。但是常常有人发问，这东西究竟有个什么卵用？ 既然您诚心诚意的发问了，我就大发慈悲地告诉您——不光有用，而且很邪恶。于是本文将会记录几个较为常用的 F12 使用方法。 警告，本文涉及各种侵权。若有不当请与我联系：1. 评论区2. 邮箱： markjuruo@163.com 再次警告，本文涉及各种侵权。若有不当请与我联系：1. 评论区2. 邮箱： markjuruo@163.com 先来点干货我们拿 网易云音乐（ https://music.163.com/ ） 当做小白鼠。 一般的，当您想要把网上的视频保存到本地，只需要在该视频上单击右键，然后选择 “视频另存为” 即可。但是网易云音乐中，您会发现鼠标右键单击后“视频另存为”的功能被十分不友好的删去了。 怎么办？我该如何下载视频呢？这个时候，F12 大法的力量便得以被使用了：不难看见，右键单击后，出现的最后一项：“检查”，便是我们所熟悉的 F12 大法。 点击之后，理应可以出现以下界面： 我们仔细观察右侧的网页代码内容，不难发现，可怜的 video 标签被裸露在外面。 video 标签中包含一项 src ，即为该视频的源地址。我们双击 src 后的内容，然后 ctrl + c 获取。 随后，复制到浏览器的地址栏中并发动搜索（按下回车）。此时，再右键单击视频，“视频另存为”便重新出现了。 再来点干货 再次警告，本文涉及各种侵权。若有不当请与我联系：1. 评论区2. 邮箱： markjuruo@163.com / 等待更新 /]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旧事记 咸鱼 11.12-11.21]]></title>
    <url>%2F2018%2F11%2F21%2Fjiu-shi-ji-xian-yu-11-12-11-21%2F</url>
    <content type="text"><![CDATA[期中考试结束了。我的成绩并不算拔尖，但我看到兴奋得哭了出来。这不是我今年第一次哭了。我总感觉自己受的委屈太多了。我是一名信息竞赛选手，却连 NOIP 的初赛都没考进过。我那么多次豪言壮志，文化课要考个好成绩出来，却总是一次又一次的让人失望。我怀疑自己，早已没有自信的资本的我准备开始堕落了。我还没尝过胜利的滋味啊。“我他妈的再也受不了了。” 第一次听到咸鱼这首歌，是在小学三年级的时候吧。我那时没什么梦想的概念，也从没想过哪一天自己会堕落成现在这个样子。我只是很喜欢这首歌的旋律罢了。我喜欢那时候的生活，我怀念那时候软软的阳光。我想那时候的我肯定很天真，天真得可爱。 咸鱼 词/曲 五月天-阿信 今年是 2018 年，而我已经初二了。我第二次听到了这首歌，是在我们班的 MV 中。我一开始只是觉得做 MV 的同学品味和我蛮搭的，可是听着听着我哭了出来。四年过去了，我发觉自己早已不是小时候期盼的样子。我似乎什么都做不成。我傻傻地看着 MV 里放着别人的荣誉，忽然有点无地自容。 我还记得去年的这个时候，我还信誓旦旦地说今年要拿个 NOIP 一等奖来。我还记得去年的这个时候，我还美好地幻想着今年的成绩会十分可喜。 “我他妈真不是个东西。”我想着。 我重新喜欢上了这首歌，但这次不是因为它的旋律。 我 如果有梦 有没有错错过才会更加明白明白坚持是什么 我被它打动了，我总觉得我的处境似乎和这咸鱼一样。只不过，等我意识到自己是只咸鱼的时候已经太晚了。我静下心来仔细思考，我究竟得到和失去了什么。 我不知道现在的自己是否真的醒悟了。但我不想再给自己哭泣的机会。毕竟我是一个天生乐观的男孩，不能辜负了我这张喜感的脸。 我不再想着否认自己是只咸鱼的事实，承认又不丢人。 我经历失败太多了，但庆幸的是我还没沦落到自暴自弃的地步。至少，我还有救。那么，我还来得及翻身。 哪里要管这么多事情，我他妈的又不是智力残缺，我他妈的才不信所谓命运。 另：预祝咸鱼的我2019年快乐]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旧事记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秋 小记 10.28-11.2]]></title>
    <url>%2F2018%2F11%2F02%2Fqiu-xiao-ji-10-28-11-2%2F</url>
    <content type="text"><![CDATA[以前我不是很喜欢秋天——谁让它总是略显单调。春天的万物复苏，夏天的生机勃勃，冬天的宁静优雅，总是让人难以忘却。但是可怜的秋天，我却总是想不出什么优秀的词来形容它的美。似乎它有的，仅仅是凄凉的冷风和枯败的落叶。 今年的我仍然是保守意见。但我不得不说，秋似乎在我眼里变得可爱了几许。 秋天的阳光的含蓄的，像是又抱琵琶半遮面的小姑娘，羞涩，却又给人以温暖。大片大片的常青木在阳光的映照下显得慵懒，却又十分可爱。 若是穿过院子后的小桥，便会一眼瞪住河潭边堆的高高的河泥。那是去年冬天挖上来的，今年便长出了一片片野草和芦苇，秋风中摇曳着，仍不败落。 河水倒映着停在岸边的废弃小船，若是在薄暮时分，会时不时透出一点点温柔的光，穿过树枝，斑斑点点的洒在地上，把空中飘散的粉尘照的一闪一闪的。太阳到了秋天，似乎也变得吝啬了，不像春天时那么洋溢，不同夏天时那么热情。只是一点点，一点点地洒在了河道旁，小路边。 秋天的云朵是害羞的。它们似乎成了珍惜物。很少很少的，在天边露出一点小角，成不了气候，却令人遐想连篇。我不喜欢没有没有雨的季节，但是那可爱的云彩暗恋般的躲躲闪闪让我不禁为之动容。 我不喜欢秋天，它干燥而又凄凉。我不喜欢秋天，它总是遮遮掩掩地展现自己的妖娆。我不喜欢秋天，但是每年我都在盼着它。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Yilia使用记录]]></title>
    <url>%2F2018%2F10%2F26%2Fhexo-theme-yilia-shi-yong-ji-lu%2F</url>
    <content type="text"><![CDATA[Hexo-Yilia 是一个优秀的 Hexo 主题，由 @Litten 开发,受到了广大 Hexo 使用者的欢迎。说它优秀有以下几个原因： 优秀的加载速度 优秀的双栏设计 优秀的智能菜单 优秀的简约画面 这样一款简约优雅的主题，能让人更加专注于文章内容。所以事实上本人是不大建议魔改的，但是有一些小小的细节可以根据个人喜好进行调整。当然，如果您要使用这款主题，您就必须明确您是以文章为中心而不是以背景和格式为中心的。 效果图redbag’s blog (http://redbag.pw/) &gt;&gt; jarworker’s blog (http://www.jarworker.cn/) &gt;&gt; markjuruo’s blog (https://markjuruo.ooo/) &gt;&gt; 安装请在命令行中打开博客根目录，然后输入：1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 基础配置Yilia 是一个优秀的双栏结构的主题，于是我们可以先来研究其左栏（ Left-Col ）。让我们来了解一下 Yilia 主题 Left-Col 中有哪些可显示并且方便个人修改的组件： 作者名称，Author 签名，Subtitle 头像，Avatar 菜单，Menu（所有文章/友链/关于我） 智能菜单，SmartMenu 联系方式，CallMe（Github/Rss/Mail/…） 头像后部背景，Header 极大的定制范畴使得同一款主题可以衍生出很多不同的风格。 Yilia 的主题格式（求求您耐心的读完这一段，千万不要吓跑）文件树：（ Yilia 文件夹下）其中，在文件夹后打*号的表示在使用过程中不会进行大量修改或是根本不用/不建议修改。12345678910111213├─languages *├─layout│ └─_partial│ └─post├─source│ ├─fonts *│ └─img└─source-src * ├─css │ ├─core │ ├─fonts │ └─img └─js 其中，大量的渲染文件放在 layout 目录下。当然，大部分的 Hexo-Theme 渲染文件也是放在 layout 下的。Yilia有着层次分明的渲染结构，十分适合二次编写。但本文主要是基于原有风格进行细节调整。您会发现在 source 目录下有一个 img 文件夹，这里面可以存放和博客效果相关的图片，在 _config.yml 文件中就可以以 /img/你的图片名称 来使用图片了，我们一般称 /img/... ， /post/... 这样的地址为相对地址，不同于 C:/bulabula/.../img/... 这样的完整地址，在同一个大目录下，相对地址的使用可以省略该大目录的地址信息。即 C:/mark/ 下，想要使用 C:/mark/img/1.jpg 就可以写成 /img/1.jpg 。 _config.yml 文件配置每款 Hexo 主题都有它的 _config.yml 文件，里面放有可以直接修改的个性化设置。于是，让我们从这说起吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# Headermenu: 主页: / 随笔: /tags/随笔/# SubNavsubnav: github: "#" weibo: "#" rss: "#" zhihu: "#" #qq: "#" #weixin: "#" #jianshu: "#" #douban: "#" #segmentfault: "#" #bilibili: "#" #acfun: "#" #mail: "mailto:litten225@qq.com" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: '目录，不存在的…'# 是否有快速回到顶部的按钮top: true# Miscellaneousbaidu_analytics: ''google_analytics: ''favicon: /favicon.png#你的头像urlavatar:#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment#不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#5、Gitmentgitment_owner: false #你的 GitHub IDgitment_repo: '' #存储评论的 repogitment_oauth: client_id: '' #client ID client_secret: '' #client secret# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#4d4d4d' # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)'# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' friends: '友链' aboutme: '关于我'friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家 以上是 Yilia 主题的 _config.yml 文件的全部内容。作者 @Litten 已经对其中内容进行了十分详细的解释，应当说是十分易懂的，因此一下将对其中一些细节进行再讲解。 左侧菜单这里的添加内容将会显示在左侧栏中， 123menu: 主页: / 随笔: /tags/随笔/ 如图： 这其中的内容可以随意添加，例如：12345menu: 主页: / 随笔: /tags/随笔/ 记录: /record 专题: /special 当然，这样做的前提是您必须先建立该页面。像这样：12hexo new page recordhexo new page special 左侧联系方式123456789101112131415161718# SubNavsubnav: github: "#" weibo: "#" rss: "#" zhihu: "#" #qq: "#" #weixin: "#" #jianshu: "#" #douban: "#" #segmentfault: "#" #bilibili: "#" #acfun: "#" #mail: "mailto:example@example.com" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#" 左侧菜单栏的下方可以添加联系方式。如果前面加了#，就代表注释掉了，将不会显示。否则，请在后面写上您相对应的联系方式的网站地址。比如：如果您只需要显示 GitHub 上的联系方式，并且您的 GitHub 个人主界面网址是 https://github.com/xiaoming ，那么您可以这样修改：1234567891011121314151617subnav: github: "https://github.com/xiaoming" #weibo: "#" #rss: "#" #zhihu: "#" #qq: "#" #weixin: "#" #jianshu: "#" #douban: "#" #segmentfault: "#" #bilibili: "#" #acfun: "#" #mail: "#" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#" 您会注意到，联系方式中有一项 mail 。这里面可以填您的邮箱，填写格式为 mailto:YourMail ，必须保证 YourMail 的填写格式正确（即必须为 ***@***.com 的格式）。当读者点击 mail 联系方式时，浏览器就会自动寻找并打开电脑上的邮件系统，收件人上会自动填上 YourMail 。 首页文章显示效果当您希望在首页，每篇文章只显示于预览时，可以使用到下面的配置： 12345678# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false 一般的， excerpt_link: more 我们不进行改动。当您的文章太长时，您可以在预览部分的后面添加 &lt;!--more--&gt; ，这样，在首页，文章便只会显示 &lt;!--more--&gt; 之前的内容。 show_all_link 即为首页每个文章右下角的展开全文的按钮，您可以按照个人喜好改变其中的内容，如改成： show_all_link: &#39;瞅一瞅&#39; mathjax ，强大的数学公式渲染器。如果您经常需要用到数学公式的，请将这一段改为 mathjax: true 。具体的 mathjax 教程详见：https://www.cnblogs.com/linxd/p/4955530.html 文章打赏功能123456789# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: 这里配置文章打赏功能。12alipay: weixin: 这两项的填写，可以先把你支付宝或微信的收款二维码图片放到主题根目录下的 /source/img 文件夹中，然后再在其后填写 /img/您保存的图片名称 。 文章目录设置1234567# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: '目录，不存在的…' Hexo 中的目录是根据您在 markdown 中书写的以 # 开头的标题来生成的。并且会根据 # 的个数来确定级数。比如：1234# title## title## title# title 那么它就会生成为：12341. title1.1. title1.2. title2. title 应当注意的是：如果 toc_hide_index 后的内容为 true ，那么生成的目录将会在每一级前面都加上序号，如：123451. title1.1. title1.2.1.title1.2.2. title2. title 其他个性设置(头像/ Top 键/分享/图标)12345678910# 是否有快速回到顶部的按钮top: truefavicon: /favicon.png#你的头像urlavatar:#是否开启分享share_jia: true 应当注意的是， avatar 和 favicon 两项，都可以先把您需要的图片放到主题根目录下的 /source/img 文件夹中，然后再在其后填写 /img/您保存的图片名称 。]]></content>
      <categories>
        <category>杂记</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo-Theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[体育课日志] 妈耶3000米 10.16-10.22]]></title>
    <url>%2F2018%2F10%2F24%2Fti-yu-ke-ri-zhi-ma-ye-3000-mi%2F</url>
    <content type="text"><![CDATA[今年升入初二的我们，最初还沾沾自喜着，在这学校里的辈分总算不是垫底了。可惜好日子不长，我们在小初一的面前光彩了几天，舒服日子没过够就开始发虚了。体育组的老师带来了扫兴的消息。似乎是区里即将对全体初二同学的体育锻炼质量进行抽测调查。因为老师们不知道究竟会抽到哪个班，于是之后对全体初二同学实施统一策略。好日子彻底结束了，每天大课间跑步从750米加到1000米，可是给的还是750米的时间。更让人全身发虚的是体育课。帅气的老唐得知了这个消息，高兴坏了：总算找到个理由折磨折磨我们了。这之后的第一节体育课，我们照常很懒散地集队。可我忽然发现唐老师的神色似乎不是很友好啊。 准备运动结束了，唐老师便开始做重要讲话。“今天我们就锻炼一下手臂肌肉，”唐老师笑的狰狞。“当然，如果你们想的话，也可以兼并腿部肌肉。”我们并未有所警惕，只是侧着身子听着。“全体趴下！”他突然吼道，“腰部不要弓起来，放平！手撑地，手掌与肩膀在同一直线上。”“俯卧撑20个，我吹哨，你们做一个。”“嘘————”“嘘————”（吹哨声）唐老师把每个哨音都拖得很长，我们只得不停的变化体位来转移疼痛。重心向前手疼，重心向后脚疼，让人十分为难。“嘘————！”最后一声哨吹干净了，我急着想要起身，结果老师又喊道“来，保持这个姿势，我们坚持1分30秒！”我把头低下了，我开始尝试各种作弊方式，来减轻疼痛。我旁边的同学也无可奈何，彻底忽视了老师“不准偷懒”的真香警告。 那天我们连做了4组。做完之后我们都神清气爽，我们领悟了这个训练的真谛事实上是锻炼我们的反应能力，如何在偷懒被老师发现前及时转换回来。当我们以为这便是训练极限时，老唐的皎洁再一次令我们为之感慨。 第二天的体育课。我们似乎是开始适应了这样的强度，有同学甚至在做俯卧撑的时候聊起了天。当然察觉到这个情况的不只有我，还有帅气的唐老师。“呦，进步得很快啊，有力气讲话呀？”我们便觉大事不妙，然后纷纷指责那些说话的同学。迟了。太迟了。被抓到了的把柄像泼出去的水一样收不回来。“有力气的话，我们多锻炼锻炼。”老唐静静地看着我们，“这样吧，接下来再做三组俯卧撑加1分30秒的平板支撑，然后每组之间间插一个1000米，可以吧？”没等我们开始抱怨，唐老师就吼道。“全部去起跑线站好！”那天，我们总共跑了3000米，80个俯卧撑，6分钟平板支撑。 就当我们以为这苦难差不多也就这样的时候，老唐再一次的刷新了难度，当然后果就是我们的反应力急剧增加，在老师发现我们偷懒前就能迅速摆好姿势。 这天的体育课我们都乖了很多，因为3000米真的跑不起，上次跑完之后走路都感觉腿在飘，我们算是跑怕了。老唐见我们这么认真，十分高兴，说打算给我们减个几组。“唐老师最帅！”“唐老师万岁！”“唐老师我爱你！”于是一片欢呼声起，使老唐有点尴尬。第二组俯卧撑时，我们开始照常偷懒，直勾勾地望着老唐，时刻准备摆好姿势，没什么在聊天，我们都觉得我们十分安全。可是似乎有个反射弧比较长的同学没及时察觉到唐老师的目光正注视着他那靠在地上休息的腿。“呦，”老唐说，“糊弄我？”“我本来好心好意想给你们减个几组的，可惜喽”“所有人，到台阶那边坐下！”我们的心开始发凉，我感到一阵不安遍袭全身。“脚放平，向前伸！手撑住后面的台阶，然后身子抬起来！”“我吹一哨，你们就往下弯曲一次手肘，听到了吗？”我们顿时发觉这个项目的难度，全身的重力全部压在手上，不出三秒手臂就像是划了口子一样剧痛。更可怕的是没有任何比较隐蔽的偷懒方式。身体比脸皮重要，这是我们半个学期提炼出来的教训。于是我们开始了一场与老唐的反应力比赛。。。 最终肯定是我们赢了这场“反应力比赛”，但我总有些感觉，老唐似乎是故意输的。他似乎是相信我们都是在拼尽全力的，是身体实在受不了才偷懒的。我突然对老唐起了感激之心。 但是即便是偷着懒做完那一组，手臂还是跟打了全麻一样的难受。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[S-Contest] 20181023-T1-排队出发(贪心/排序)]]></title>
    <url>%2F2018%2F10%2F24%2Fs-contest20181023-t1-pai-dui-chu-fa%2F</url>
    <content type="text"><![CDATA[题目描述神牛岛是传说中的一个岛屿，凡是成功到那里游历，完成探险并返回的人，都会成为神牛。但是，现实中却没有人知道如何到达神牛岛。这天夜里，笃志者睡着之后，不久就进入了梦乡。他突然看到有人在问，“有人想去神牛岛的吗？”神牛岛之旅的牌子前，就开始有不少勇士报名要去冒险探索。“我们会把勇士安排在前，带领大家一起去神牛岛。下面开始点名！”管理队伍的LXY神牛说。其实说实话，给学生排队这种工作是最让神牛头疼的了。因为同学们都有自尊心，都不愿意排后面。共有n个同学要排成一列，每个同学有两个属性：影响力和承受能力。给一个同学造成的心理创伤指数等于所有在他前面同学的影响力之和减去他的承受能力。现在请你帮忙安排一下点名顺序，尽量使受到心理创伤最大的同学少受创伤。 输入&amp;输出细则【输入】 输入文件1.in包含n+1行：第1行是整数n，表示同学的个数。第2~n+1行每行两个自然数，分别是该同学的影响力和承受能力。 【输出】 输出文件1.out包含1行，为你安排的顺序中受到心理创伤最大的同学受到的创伤。 输入输出样例：1234567INPUT:3 10 3 2 5 3 3 OUTPUT:2 【数据规模】对于100％的数据，1&lt;=n&lt;=50000，1&lt;=影响力&lt;=10000，1&lt;=承受能力&lt;=1,000,000,000。 题解没错这就是一道简单的贪心。而且理解起来并不麻烦。我们规定$a_i$表示第i个人的影响力，$b_i$表示第i个人的承受能力。不难发现，这道题我所知道的最优思路就是先对这组数据进行排序，而排序的方式必定与$a_i$和$b_i$有着某种玄学联系。之后，对排序好的数据进行贪心运算即可。题目的数据无法保证单调性，所以二分和二分答案是难以实现的。 –By DPair题目数据不保证无后效性，所以动规是难以实现的。于是，我们可以得到这道题的基础模板：12345678for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i];for(i=0;i&lt;n;i++) index[i]=1;//index表示元素在序列中排在第几位sort(index.index+n,cmp);ans=-INF;tmp=0;for(i=0;i&lt;n;i++)&#123; ans=max(ans,tmp-b[index[i]]); tmp+=a[index[i]];&#125; 当然，以上这段用结构体来表示更容易理解。那么我们只要来简单推一下cmp的内容即可。由题目可得，对于相邻两个数i，j，他们的先后顺序对其后面的数不造成影响。 不论是i在前还是j在前，他们的影响度总和都是$a_i+b_i$ 由题意可得，影响力越大排名越靠后，承受能力越小排名越靠前。为了把这两个量统一考虑，我们单独考虑ij两人中排序后两人靠后的那个人心理创伤指数的大小，并以此作为排序因子。123int cmp(int i,int j)&#123; return a[i]-b[j]&lt;a[j]-b[i];&#125; 由此完成。源码不供。 蹲坑记以上思路全部都是在看过我们同学@DPair同学的题解后写出的，相当于复述。但是事实上一开始我的思路并不是如此。并且，在经过几位大佬的帮助下，我逐渐清晰了自己的思路。我们规定$a_i$表示第i个人的影响力，$b_i$表示第i个人的承受能力，$Q_i$表示第i个人当前排序情况下的心理创伤指数。设$sum_i$为第1~i个人的影响力之和。勒令第i个人与第j个人相邻。 当i在j前时：$Q_i = sum_{i-1} - b_i$$Q_j = sum_{i-1} + a_i - b_j$ 当j在i前时：$Q_i = sum_{i-1} + a_j - b_i$$Q_j = sum_{i-1} - b_j$ 而我们现在需要的是其中的最大值，那么便是：$max ( Q_i,Q_j )$其中包含以上罗列的$Q_i$和$Q_j$的两种不同情况提取出$sum_{i-1}$可得到最大值即为：$max( -b_i , a_i -b_j , -b_j , a_j-b_i )+sum_{i-1}$ 此时，我们假设i排在j前面不难得到，此时两人中心理创伤指数最大值即为：$max ( Q_i, Q_j ) $$= max ( sum_{i-1}-b_i,sum_{i-1}+a_i-b_j ) $$= max ( -b_i,a_i-b_j ) +sum_{i-1} $我们不妨把max内的两数都加上$b_i+b_j$，然后在max外减去，不难得出$max ( b_j,a_i+b_i )-b_i-b_j+sum_{i-1} $ 当$a_i+b_i&gt;a_j+b_j$时得到$a_i+b_i&gt;b_j$,最大值为$a_i+b_i$由于此时$a_i+b_i$是$a_i+b_i$,$a_j+b_j,b_i,b_j$中最大的，所以此时受到伤害最大当$a_i+b_i&lt;a_j+b_j$时最大值为$a_i+b_i或b_j$。而这个值必然小于$a_j+b_j$。所以我们让$a_i+b_i&lt;a_j+b_j$能比让$a_i+b_i&gt;a_j+b_j$得到更优的解。 于是我们可以得出排序基准：a[i]+[i]&lt;a[j]+b[j]于是得到排序函数为：123int cmp(int i,int j)&#123; return a[i]+b[i]&lt;a[j]+b[j];&#125; 观察一下不难发现其实它和a[i]-b[j]&lt;a[j]-b[i]完全没有区别，但是它们的推导过程大相径庭。 感谢@Onglu的帮助。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>贪心</tag>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material化Windows桌面任务栏]]></title>
    <url>%2F2018%2F10%2F23%2Fmaterial-hua-windows-zhuo-mian-ce-bian-lan%2F</url>
    <content type="text"><![CDATA[关于让Windows桌面任务栏透明化/毛玻璃化的方案。 本文内容为转载，本文原作者：@Torther十分感谢@Torther提供的方案。 对于某些追求美感的人来说，让任务栏变透明一定是一个福音。正文注：本篇教程共有两种方案，请按照自己使用习惯进行选择。且本篇教程仅支持 Windows 10 ，且两款软件均有官方汉化。第一种方案&nbsp; &nbsp; TranslucentTB ，一个轻量级实用程序，使 Windows 任务栏半透明/透明。效果图特征使用支持 Alpha 和实时预览的先进颜色选取器以更改任务栏的颜色。可供选择的任务栏状态模糊：会使任务栏变模糊，如效果图一。透明：让你的任务栏变得全透明，如效果图二。正常：仿佛没有运行 TranslucentTB 。不透明：没有透明度动态模式（这些功能可以一起使用）动态 Windows ：如果窗口最大化，则会将任务栏更改为其他外观。动态开始菜单：打开开始菜单时将更改任务栏外观。动态 Cortana：当 Cortana 打开时，将更改任务栏外观。动态时间轴/任务视图：当时间轴（或旧版本上的任务视图）打开时，将更改任务栏外观。能够显示或隐藏Aero Peek按钮。可随意定制。下载&nbsp; &nbsp; 你可以在 Microsoft Store 免费下载该程序的 UWP 版本，并保持后台更新和设置同步功能。&nbsp; &nbsp; 当然，你也可以选择安装程序将其安装到您的计算机：点我下载启动&nbsp; &nbsp; 要将 TranslucentTB 添加到开机启动，请检查 TranslucentTB 托盘图标菜单中的“在启动时打开”条目。如果它显示为灰色，则说明在任务管理器或您的组织内禁用 TranslucentTB 启动。第二种方案&nbsp; &nbsp; 如果你单纯想让任务栏变透明的话，第一种方案已经可以满足了。而第二种方案可能有些人已经听过它的名字：StartlsBack++&nbsp; &nbsp; StartlsBack++是一款开始菜单自定义增强工具，同时它也集成了任务栏透明美化功能。同时如果你怀念Windows 7 的开始菜单的话，你也可以使用这款软件。重要的是，它不需要自启，设置完毕后即可关闭，相比第一种方案，它减少了很多步骤，也是本人正在使用的。注：效果图就不放出了，和第一种方案是一样的。下载正版购买：官网网络上均有大量破解版，请谨慎下载，但在这里本人还是推荐入正。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[项目] EasyHexo-Hexo从入门到入土]]></title>
    <url>%2F2018%2F10%2F19%2Fxiang-mu-easyhexo-hexo-cong-ru-men-dao-ru-tu%2F</url>
    <content type="text"><![CDATA[参与了一个小项目，据说是为了给想写博客的同学一个系统的帮助。该项目由一位胸怀大志的同学ChungZH提出。由于我以前走过的坑和弯路太多了，所以决定把所有的经验整理出来，也算是一种贡献。后续将持续更新 START | Master: ChungZH 项目名称：EasyHexo项目地址：https://github.com/EasyHexo/Easy-Hexo项目仓库：Github项目成员：ChungZH Anoyer MarkJuruo moshiyeap StaunchKai Michael yixiaomie（截止至2018-10-20，8:30）项目内容：Hexo的入门，基础配置，主题配置，各个主题魔改攻略&amp;部分插件使用套路，适合主题的自定义页面创作，制作个人主题等。项目主旨：给予想要拥有一个清静、干爽的个人博客的同学一个良好的帮助！项目规划：]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F10%2F14%2Fnoip2018-you-ji%2F</url>
    <content type="text"><![CDATA[从初一我入坑开始，我便经常幻想着有一天能够在这信竞道路上发光发亮。事实证明，我想得真美。我不是一个很实在的人，但是总是很努力地“表现地很努力”。终于，在我最热爱的道路上栽了大跟头。这不是什么值得宣扬的事迹。我也为此痛哭。记录以铭。 上午是学校的统一体检。我们信奥生便自成一班，早早地做完了所有的检查。我们忍不住欲望跑去了机房。可惜时间所迫，并未有多长时间给我们肝题。离开机房前，我在机房里踱了一圈步。这是我曾经奋斗的地方啊。 中午吃了比较丰盛的必胜客。虽然是外卖但还是很开心。我于是趴在车的后座上睡了过去。醒来，便上路了。沿路的风景越来越荒凉，我便知道离考场越来越近了。终于，目的地“杭十四中康桥校区”已然在眼前。周围的景色十分怡人。算不上秀丽，但不那么嘈杂，除了突然窜出来的几辆工程车显得不是很友好。从外面看，杭十四中康桥校区的校园似乎很大，许许多多的教学楼整齐的排列在空旷的校园中。这是非常美好的一天吧。这会是我圆梦的一天吧。 人多了起来，我们于是蜂拥而入，在校园里走动着，探讨着题目。我们学校的学生非常多，有包场的节奏。我们一群一群，围在一起，互相祝愿，然后各自前往自己的考场。我例行去了趟厕所。厕所很大，窗户外面可以俯视操场。到了考场，那个一脸黑线的监考官已经站在讲台前摆弄着密封的试卷带。“书包要放出去。”他看到我们一群穿着相同校服的同学说道。 考试很快就开始。卷子刚发下来，我粗略的扫了一遍，不觉的很难，但也未尝十分容易。“中国青少年计算机协会与哪一年成立？”“不用进行关键字比较的是哪一种排序？”“广域网的简称到底是WAN还是LAN？”“……”我越看越难受，为什么我都不知道。“几道选择题，没什么大不了的”我这样安慰自己，往下读题。“一道数学题，没什么大不了的”“两道程序题，没什么大不了的”“三、四到完型题，没什么大不了的”“……”“完了。”我十分难受，再看了一遍卷子。我发觉似乎稳的分数只有60多。我于是纠结于那八分一道的程序题。一直纠结到考试结束。没算出来。 浙江的确不是一个友好的地方。全国数一数二的信奥强省，是许多人梦寐以求的圣地，却也成为了许许多多信竞人梦想的火葬场。不少人这样调侃着：“信奥的难度进阶：入门-&gt;简单-&gt;普通-&gt;困难-&gt;炼狱-&gt;浙江”。我实力本就不强，却又生在了浙江赛区，没有足够的努力，何来送到门前的荣耀。“一个连文化课都不得尽善的人却去搞竞赛，可笑至极。”如果我能从这次失败中吸取教训的话。那也许是我至今最大的成功。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS从入门到入土]]></title>
    <url>%2F2018%2F10%2F03%2Fvbs-cong-ru-men-dao-ru-tu%2F</url>
    <content type="text"><![CDATA[首先，想学VBScript的同学们必须知道，如果是真的想要学好编程的，那么VBSCript不该作为长久的选择，学习VBScript为的是基本了解编程语言中的基本语法（所有的程序语言语法都是相通的）。VBScript上手快，成效快，因而很适合程序新手学习。开始学习前希望您具备以下基本条件： 有一定英语基础 有一定耐心 Windows操作系统（本人不清楚Linux/Mac是否可以） 本文针对程序小白而写，请各位大佬快速护目 如何编写/编译VBScript程序由于我们现在学习的VBScript没有专门的编辑器，于是我们可以选择在记事本/写字板中书写程序。写好一个VBScript程序之后，只要把该文件的后缀名改为.vbs即可，计算机会自动编译。要注意，这边一定要把文件类型选择为所有类型，要不然会有些不可描述的错误。如果需要再次编辑同一个VBScript文件的话，可以右击该VBScript文件，然后选择【打开方式】，选择记事本即可。 输出其实这样写的话顺序是有点问题的，理论上应当先讲变量。但是鉴于同学们希望早点看到自己写的程序的作用，就先把最基本的输出讲掉。1Msgbox "Boy♂Next♂Door" 同学们吧以上语句复制到文本框中然后按以上讲的方法编译。点开来之后，同学们会发现自己的第一个程序已经可以正常运行了。这个程序的意义就是：把”Boy♂Next♂Door”这一串字串放到消息提示框里输出。Msgbox（MessageBox)，就是一个保留关键字。 什么是关键字？关键字就是VBScript中可以进行操作的单词/符号。可以理解为英语中的动词，告诉你接下来要干什么。在VBScript中，关键字没有大小写规范。形象一点的说，就是前面的讲到的那个最基本的Msgbox有以下几种正确写法。12345msgboxMsgBoxmsgBoxMSGBOXand more... 在具体的程序实现中，同学们就可以根据自己个人的习惯选择写法。 变量变量很好很好理解，但是很难彻底搞懂它的用途，而且如果是第一次听到的话—— “这种累赘的东西，不如不要”——鲁迅 先看下面一个例子123dim aa="Boy♂Next♂Door"Msgbox a 简单的说，变量就是一个箱子，里面装着一个东西，我们称这个东西为该变量的值。在引用某个变量的时候，事实上用的变量的值，也就是说，上面那个程序里面的Msgbox a和直接Msgbox &quot;Boy♂Next♂Door&quot;等效。 变量的类型讲到变量就不得不提一个很影响人的心情的知识点，这也是学习过程中的第一个难点——变量的类型。变量的类型是由变量里具体存的值决定的。比如我们刚讲到的那个程序：123dim aa="Boy♂Next♂Door"Msgbox a 其中a就是一种字符串类型，我们可以简单的理解为它的值是由许多字符组成的。123dim aa=1Msgbox a 此时，a=1，那么a就是一个数字类型了。由于我们学的VBScript语言没有严格的变量规定，于是我们都用dim来声明变量，然后给这个变量赋值后计算机会根据其值自动判断其变量类型。在我的母语C++中，变量有着非常严格的要求，不同的类型有不同的关键字来声明，大家感受一下即可：12345//这是C++语言，大家不必深入了解int a;//数字类型bool b;//布尔类型（false/true）char c;//字符类型（只有一个字符）string d;//字符串类型（有多个字符） 不同类型变量间的运算符提一句，在VBScript程序中出现rem，就便是其后面的语言都是用于注释，也就是不会被执行。12345678dim a,b,c,d rem 声明a,b,c,d四个变量a=1b=1c="Boy♂NexT♂"d="Door"Msgbox a+bMsgbox c+dMsgbox a&amp;c 这个程序中a,b都为数字类型，于是他们进行+运算就是和我们数学上的运算一样，但c和d是字符串类型，所以他们进行+运算就是把这两个字符串连接在一起。最后一句：Msgbox a&amp;c这边a和c之间用了&amp;连接（shift+7)，是因为它们的类型不一样，当类型不同又想在同一个MessageBox中输出，就得用&amp;把他们连接在一起。当然，在MsgBox中同类型也可以用&amp;链接123456dim a,b rem 声明a,b两个变量dim ca=1b=2c=a+bMsgbox a&amp;"+"&amp;b"="&amp;c 此时,我们又声明了一个变量：c来保存a+b的值。因为a和b都是数字类型，于是c也自然而然的为数字类型了。输出的时候注意”+”和”=”都是字符（串）类型，所以a,b,c和”+”，”=”的类型不同，在Msgbox中得用&amp;连接。 值得思考的问题1234dim a,b,c rem 声明a,b,c三个变量a="1"b="2"c=a+b 在这样一个程序中，c=a+b，由于a,b都是字符（串）类型，导致c也是字符串类型。前面讲到字符串运算中，+表示连接，因此，c的值此时就为”12”。问题来了：如何让c的值为数字a+数字b呢？（也就是如何令c=1+2的值而非”1”+”2”的值）。我们有一种特殊的处理方法：1c=0+a+b 此时，计算机发现0是一个数字，也就会默认把c的值确定为数字类型了。 输入之所以先讲变量，就是为了为这里的输入做铺垫。从这里开始，我们学的程序才真正开始有点意思了。123dim aa=Iputbox("输入些东西。。。")Msgbox a 这个程序里多了个新东西——Inputbox。也就是输入框。这个输入框的作用就是让用户输入信息，然后把用户输入信息的值赋值给变量前面的变量。而Inputbox里面的东西就是提示信息。 课后练习-小试牛刀尝试写一个程序，达到以下效果：请认真完成后再打开正解 If-Else判断语句接下来是更加有意思的了，并且接下来我们学习的程序将会变得长♂起来。假如我想实现这么一个程序：让用户输入一个值，假如值为“markjuruo”，则输出“他是个大帅哥”，否则输出“他是头大笨驴”，该如何实现？我们先来看一下正解：1234567dim namename=Inputbox("你叫什么？")If name="markjuruo" ThenMsgbox "他是个大帅哥"ElseMsgbox "他是头大笨驴"End If 这里有可能会略微有点难以理解，但不要急，我会慢慢讲。 If的三种形态123If 条件 Then运行程序End If 当条件成立时，从Then到EndIf间的所有程序才会被执行。12345If 条件 Then运行程序Else运行程序End If 如果条件成立，那么运行从Then到Else之间的所有程序。如果条件为假，那么运行从Else到EndIf之间的所有程序。1234567If 条件1 Then运行程序ElseIf 条件2 Then 运行程序Else运行程序End If 这是if语句的究极形态，学会了它就可以为♂所♂欲♂为！。如果条件1成立，那么执行从If 条件1 Then到ElseIf之间的内容，如果条件2成立，那么执行从ElseIf 条件2 Then到Else之间的内容。如果条件1和条件2都不成立，那么就执行从Else到EndIf之间的内容。需要注意的是，这里可以有多个ElseIf出现，比如：12345678910If 条件1 Then运行程序ElseIf 条件2 Then 运行程序ElseIf 条件3 Then运行程序ElseIf 条件4 ThenElse运行程序End If 并且，在If,ElseIf的结构中可以省略Else，比如：12345If 条件1 Then运行程序ElseIf 条件2 Then 运行程序End If 注：以上所有If，End If，Else，ElseIf的大小写全部可以自己决定这边确实有一点难以理解，但是稍加思考，肯定可以成功的。至此，我们再回头看那刚开始学的程序： 假如我想实现这么一个程序：让用户输入一个值，假如值为“markjuruo”，则输出“他是个大帅哥”，否则输出“他是头大笨驴”，该如何实现？ 1234567dim name rem 声明变量namename=Inputbox("你叫什么？") rem 输入name的值If name="markjuruo" thenMsgbox "他是个大帅哥" ElseMsgbox "他是头大笨驴"End If 需要注意的是，If中的=表示判断两个数是不是相等，如果相等，那么条件式成立。例如该程序中If name=&quot;markjuruo&quot; Then，就是当name的值为”markjuruo”时，条件式成立。当然喽，这里的比较只是同类型之间的，如果类型不相同的话就肯定不相同，比如13不等于“13” 课后练习-自制计算器问题首先输入两个数，然后再输入计算的符号（中文的“加”，“减”，“乘”，“除”），最后输出计算的结果。同时判断如果输入的计算符号不合法（就是不为“加”，“减”，“乘”，“除”中的任何一个），那么输出“Are You Killing Me ? ? ? ”由于可能对你们来说难度有点大，我给出一点提示：写法1 | 先把答案保存在变量ans中，最后输出（这是一种好习惯）12345678910111213dim num1,num2,task,ans rem 数字1，数字2，计算符号，结果num1=inputbox("输入数字1")num2=inputbox("输入数字2")task=inputbox("输入计算符号")if task="+" Thenans=0+num1+num2 rem 前面加上0，强制转为数字相加ElseIf task="-" Then......ElseMsgbox "Are You Killing Me ? ? ? "EndIfMsgbox num1&amp;task&amp;num2&amp;"="ans rem 想一想这一句的效果 写法2 | 算出来就输出123456789101112dim num1,num2,task rem 数字1，数字2，计算符号num1=inputbox("输入数字1")num2=inputbox("输入数字2")task=inputbox("输入计算符号")if task="+" ThenMsgbox num1&amp;task&amp;num2&amp;"="&amp;(0+num1+num2)ElseIf task="-" Then......ElseMsgbox "Are You Killing Me ? ? ? "EndIf 正解超高难度变式 | 前面不变，但是除法要算出整除得到的商和余数。（取余符号：mod，比如8 mod 3=2，7 mod 2=1） 阶段性技巧总结计算符号问题：在VBScript中，基本的加减乘除四则运算符号为+,-,*,/不可以用×或÷。求余符号为mod。其它的运算暂时不学习。 用了一段时间的Inputbox之后同学们会发现，不论用户往Inputbox中输入什么数据，它总会把这个数据变成字符串类型的。比如你输入一个13，它却会给你“13”，在之后运算的过程中还得+0处理才能当做数字使用，十分不雅观。于是我们可以在输入的时候就处理掉：12dim numbernumber=Inputbox("输入一个数字")+0 这时，number就可以直接作为数字使用。这里可能有同学不明白了,Inputbox()怎么还能+0呢？这里要好好理解，Inputbox()其实也是有值的，它的值就是用户输入的值。接下来学到函数就会明白，Inputbox()是一个函数，它是有返回值的，当然现在不必深究，了解即可，应当循序渐进。 在Msgbox中如何换行？？很简单，只要在需要换号的地方加上chr(13)就行了。1Msgbox "Hello!"&amp;chr(13)&amp;"How are you?" 这种方法当然在Inputbox中等效：12dim iptipt=Inputbox("Hello!"&amp;chr(13)&amp;"What's your name?") If中的判断语法有哪些？上次我们在讲到If-Else语法中只提到一种判断方式：判断两个（同类型的）变量的值是否相同。此处拓展一些：1234567dim a,ba=1b=2If a=b then rem 判断是否相等ElseIf a&lt;b then rem 判断a是否小于bElseIf a&gt;b then rem 同理ElseIf a&lt;&gt;b then rem 判断a是否不等于b 别的当然还有很多，但此处不做拓展。 循环语句请务必掌握了前面讲到的所有语法后再学习本节内容很好，你已经学会了许多VBScript用法了！但是光凭以上提到的语法，程序的质量和作用都不会很高。现在，我们要来学习一个分重要的语法：循环语句。先来看一个小问题：让你将1~10分别输出，该怎么做？凭借我们之前学习的语法，自然而然就会想到：123456Msgbox "1"Msgbox "2"Msgbox "3"...Msgbox "9"Msgbox "10" 那么，如果我要输出1~100呢？甚至是1~1e7呢？很明显，上述方法的效率就显得过于低下了。我先给出正解，之后会细讲语法，这一块内容有很强的综合性，我们将会结合之前学过的If语法进行学习。在这一节，我们将会接触两种循环方式，以上题为例：For循环123For i=1 To 10Msgbox iNext Do-Loop循环123456789dim ii=0Doi=i+1Msgbox iIf i=10 ThenExit DoEnd IfLoop Do-Loop循环鉴于这个循环使用到了我们之前所学习的If语法，可能会更好理解些，故而先讲。123Do运行程序（循环体）Loop Do-Loop循环十分好理解，就是把Do和Loop中间的程序一直重复执行。鉴于这样一直运行会让人不爽，我们就需要在一定的条件下终止运行。123456Do运行程序（循环体）If 条件满足 ThenExit DoEnd IfLoop 这时候，我们原先学习的If语法就起了极大的作用。当满足条件时，执行语句Exit Do。Exit Do，顾名思义，就是退出循环。例如我们刚看到的那个示例程序：123456789dim ii=0Doi=i+1 rem 自增1，这个好好理解下Msgbox i rem 输出iIf i=10 Then rem 当i等于10时，退出循环Exit Do End IfLoop 这里面有一个语法：i=i+1，这个需要好好理解，有的同学可能会这样想：比如i=1，那岂不是1=1+1了吗？注意，i是一个变量！在执行i=i+1时是把i+1的值赋给了i。当然如果实在理解不了，那就这样写：123dim xx=ii=x+1 这样分开写就更好理解了。 For循环这个循环将会非常常用，但理解起来可能有点复杂。123For i=1 To 10运行程序（循环体）Next 在这个程序中，i充当了计数器的作用。For i=1 To 10也就是i从1到10循环，每次循环都把For与Next之间的内容执行一遍。应当注意这里的i不需要提前声明，在For i=1 To 10中，i已经被系统自动声明了。这里有一个重点是：这个程序中i只能在循环体内使用（涉及到了全局变量和局部变量，比较复杂，好好理解）。也就是：1234For i=1 To 10Msgbox i rem For中声明的i变量只能在For-Next之间用NextMsgbox i rem 在这里用i系统会报错，因为For结束后i变量会被自动清空 拓展 | 如何才能让i每一次递增k之前讲到的For循环，每一次都是默认递增1的，但是如何做到每一次都递增k（即任意实数）呢？举一个比较实际的例子：试写一个程序，输出0~n之间的偶数。我这里直接放出正解：12345dim nn=Inputbox("输入n的值")For i=0 To n Step 2Msgbox iNext 注意到了吗？For i=0 To n的后面加上了Step 2,这就表示每次都递增2。当然喽，这种For-Next语句中很多量都是可以自定义的：1For OK=OK To OK Step OK 其中标注OK的都是可以自己调控的量。 接着拓展 | 如何倒过来输出0~n的偶数？即以n,n-2,n-4…4,2,0的顺序输出这个问题乍一看摸不着头脑，但只要掌握了前面讲的“For-Next循环很多量都是可以自己定义的”就不难解决了。12345dim nn=Inputbox("输入n的值")For i=n To 0 Step -2Msgbox iNext 怎么样？是不是恍然大悟？ 再来个拓展 | 如何根据特殊条件终端For循环？还记得Exit Do吗？相信同学们猜得到结束For循环就是Exit For了。而根据特殊条件嘛，就是一个简单的If判断，轻松解决，此处不多赘述了。 课后练习-求和问题首先用户输入一个n，接下来输入n个数，最后请输出这n个数的和。温馨提示：别忘了强制转为数字类型正解 超高难度变式 | 这个若是对你们来说能自己做出来就不得了了前面都一样，但是最后输出的形式为$x_1+x_2+x_3+…+x_n=sum$，其中$x_i$表示输入的第i个数，$sum$表示它们的和。例如：“1+4+5+2=12” 提示一下，还记得字符串怎样相加的吗？可以设置一个字符串，每一次循环都在该字符串的最后加上“+$x_i$”，最后就可以得到一个字符串形如”$x_1+x_2+x_3…+x_n$” 正解 课后练习-求最大值问题首先用户输入一个n，接下来输入n个数，最后请输出这n个数中的最大数为多少。（这道题对你们来说也蛮难的） 提示一下，可以设置一个最大值max，然后先让这个max等于第一个输入的数，然后之后每一次输入都比较max和输入的数，如果max比输入的数小就更新max的值。 正解 函数大部分语言都有函数，VBScript也不例外。当然，这里讲的函数和我们数学上的不大一样。在VBScript中，函数就是定义一段过程。我们来放轻松，看一段简单的函数代码：123Function AWC()Msgbox "Ass We Can"End Function 这就是一个函数。简洁，清晰。那么写好这个函数之后，在程序中我们就可以这样用它：1AWC() 我来举个十分有意思的比喻：我们一般的写程序，可以理解为堂食，买来了就吃，而函数就类似于打包，买来了，要吃的时候再拿出来吃，而且想吃多少次就吃多少次。 带参数的函数讲到函数就不得不将参数。参数是什么？我们来看看下面这个简单的例子：123Function Say(dim sb,dim say) rem 这个s.b.是somebody的意思Msgbox sb+"说"+sayEnd Function 这里，sb和say就是参数。参数就相当于函数运算过程中需要用到的变量，可以有，也可以没有，可以多，也可以少。那么带参数的函数，我们在引用的时候是不能加上括号的：1Say "我","AssWeCan" （这里比较难理解，我也不知道我讲清楚了没，如有不懂的在下面提问即可） 课后练习-求阶乘和问题这道题是我们信奥生在初学的时候的必做题，对我们来说十分简单，至少它没有涉及算法内容，放到这里来，给大家练练手。让用户输入一个n，然后输出$1!+2!+3!+4!+…+n!$的值。 提示：计算每个数的阶乘的过程可以写成函数。 数组很好，你已经学到数组了。这是一个很有趣的东西，而且我懒的解释，大家自己看程序就能立马明白它的用途：12345dim array(3)array(1)="我"array(2)="是"array(3)="你爸爸"Msgbox array(1)+array(2)+array(3) 是不是很简单？不就是几个量的集合嘛！ 动态数组//不行，我实在写不动了。。。 （持续更新中。。。）]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[EOJ] Monthly 2018.10一题总结(模拟)]]></title>
    <url>%2F2018%2F10%2F02%2Feoj-monthly-2018-10-yi-ti-zong-jie%2F</url>
    <content type="text"><![CDATA[由于我太蒻了，所以只写对了一题的代码：《Problem A. oxx 的小姐姐们》由于我太蒻了，看不出这是数学题，就打了个十分暴力的模拟程序。 题目描述oxx 和他的小姐姐（们）躺在图书馆前的大草坪上看星星。有强迫症的 oxx 想要使得他的小姐姐们正好躺成一块$n×m$的长方形。已知小姐姐的形状是$1×p$的长方形（可以横着或竖着躺）。小姐姐从$1$到$nm$编号总共有$nm$个（如果可以的话，绝对够用）。P.S. 小姐姐是$1×p$的是因为她们比较苗条。 输入说明输入三个整数$n, m, p$($1≤n,m,p≤100$，$p$是质数)。 输出说明如果不行，输出No。否则输出Yes。随后输出$n$行$m$列正整数用空格隔开。同一个小姐姐用相同的数字表示，不同的小姐姐用不同的数字表示。数字应是在$[1，nm]$范围内的正整数。同一个数字至多出现$p$ 次，这$p$次应该在横向连续，或者纵向连续。如果有多解输出任意一解。 输入输出示例见原题目（数据太多了，懒得复制）EOJ Monthly 2018.10 - A. oxx 的小姐姐们 满分暴力我的思路：先放竖着的姐姐，然后扫一遍地图看看还有没有空余，若有空余就放横着的姐姐。由于事先判断了是否能刚好放成$nm$的长方形，因此之后就大胆的摆即可。当然全部摆好了之后也不忘记严谨的扫一遍图，看有没有剩下没放了（虽然没有实际作用了）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=110;int n,m,p;int map[MAXN][MAXN];int rewn,rewm,tmpn,tmpm;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;p); if((n*m)%p)&#123;//p不是nm的倍数肯定就放不了了 puts("No"); return 0; &#125; int count=0;//小姐姐计数器 if(p&lt;=n)&#123;//如果竖排放得下 int tmp=1;//在当前这一高度时横着摆了几个竖排 int h=1;//当前摆到第几行了 while(h&lt;=n-p+1)&#123;//一直放小姐姐直到当前行放不下为止 while(tmp&lt;=m)&#123;//在这一行一直放小姐姐直到放满这一列 if(!map[h][tmp])&#123;//（其实没啥用）如果当前行为空 ++count;//小姐姐计数器++ for(int i=h;i&lt;=h+p-1;i++)&#123; map[i][tmp]=count;//纵向放置小姐姐 &#125; &#125; ++tmp; &#125; h+=p;//调到下一高度 tmp=1; &#125; &#125; bool flag=true;//flag=false for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; flag&amp;=map[i][j];//flag|=map[i][j]; &#125; &#125; //扫一遍图。。。注释里是第一遍时写的，，滑稽地卡在了第七个点 if(!flag &amp;&amp; p&lt;=m)&#123;//如果还没放满，那么接着放横向小姐姐 int tmp=1; int w=1; while(w&lt;=m-p+1)&#123; while(tmp&lt;=n)&#123; if(!map[tmp][w])&#123; ++count; for(int i=w;i&lt;=w+p-1;i++)&#123; map[tmp][i]=count; &#125; &#125; ++tmp; &#125; w+=p; tmp=1; &#125; &#125; flag=true; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; flag&amp;=map[i][j]; &#125; &#125; //再扫一遍图 if(!flag)&#123;//如果仍然没放满那么输出No puts("No"); return 0; &#125; puts("Yes"); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout&lt;&lt;map[i][j]&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论-二分图匹配]]></title>
    <url>%2F2018%2F09%2F26%2Ftu-lun-er-fen-tu-pi-pei%2F</url>
    <content type="text"><![CDATA[匈牙利算法本文内容大部分参考Dark_Scope《趣写算法系列之–匈牙利算法 》这是一个有趣的算法。没有复杂的技巧，只是几句循环判断形象地说，在这个算法中，我们充当的是媒婆的角色，帮助两方的角色进行匹配。 匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1955年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig$和Jenő Egerváry的工作之上创建起来的。—— By 著名权威学者-百度词条 理解举个比较实际的栗子lzh非常喜欢立Flag，他成立了自己的立Flag团（一下简称F团）。今天F团团长lzh又招到了新人手，lzh开始感到麻烦了，因为他不知道怎样给F团的新成员们分配flag。lzh给新成员们展示了可供分配的flag，然后询问了每个新成员的心仪的flag。他找到了你，想让你解决这个分配问题。lzh会提供给你可供分配的旗帜信息、每个成员的信息和他们的心仪flag。保证没有哪个不可描述的成员会对未提供的flag感兴趣。于是乎，我们现在需要做的就是给F团的新成员分配flag并且最好让每个人都能拿到自己喜欢的flag。我们可以把这个问题先抽象成一张图来：把人和旗帜先分成两队。我们假设滑稽1，2喜欢爆0（暴少了个火字旁实在抱歉），滑稽1喜欢溢出，滑稽1，2，3，4都喜欢AK-IOI，于是可得出关系图。图中黄色的先表示喜欢（当然是理解为有向，只有人会喜欢flag，flag不会喜欢人的）开始分配旗帜，首先把滑稽1所心仪的第一个未被分配的旗帜分配给他，也就是爆0，其中用蓝色的线表示该旗帜分配给滑稽1，则可得图。紧接着按照上一步，把滑稽2喜欢的第一个未被分配的旗帜分配给他。这时发现滑稽1已经把爆0分配到了，那么此时采用和平原则，滑稽2退而分配AK-IOI，则可得图。轮到滑稽3了，发觉：不好！AK-IOI被滑稽2拿走了！滑稽3不甘把AK-IOI的机会让给滑稽2，于是和滑稽2进行了深度沟通，于是滑稽2答应的换面旗帜。滑稽2答应后发觉事情没这么简单，他唯一能换的旗帜被滑稽1拿走了。于是他只好去和滑稽1聊了聊。滑稽1于是好心的让出了爆0的旗帜，选择了溢出。其中橙色的线表示暂时撤销该分配关系。于是滑稽2可以换上了爆0的旗帜滑稽3开心的拿到了AK-IOI的旗帜接下来留下了滑稽4，可是不论怎样让步也无法给他腾出他心仪的旗帜了（可以自己推导一下）。于是我们就得到了最终的分配情况。 算法实现简单的DFS+循环。前置条件当然是得会写个简单的递归函数。1234567891011121314bool find(int x)&#123; int i,j; for (j=1;j&lt;=m;j++)&#123; //扫描每个flag if(line[x][j]==true &amp;&amp; used[j]==false)&#123; used[j]=1; if(girl[j]==0 || find(girl[j]))&#123; girl[j]=x; return true; &#125; &#125; &#125; return false;&#125; （持续更新中…）]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[体育课日志] 大雨，大雨 9.20]]></title>
    <url>%2F2018%2F09%2F23%2Fti-yu-ke-ri-zhi-da-yu-da-yu%2F</url>
    <content type="text"><![CDATA[这样闷热的日子已经持续好几天了。我们没什么身体上的不爽，但就是不过瘾。已经入了秋，总得抓住夏天的尾巴，好好的下一场痛快的大雨。南方的天气，果真羞涩，总像是藏着掖着，让人难受。或者说，我不大习惯这种扭捏的风态。至少，在活泼的夏天里，这种态度实在不是很友好。每一节体育课，我们都盼着跑完这一圈就忽然乌云密布，然后“哗”的把腹中的雨水全都倾盆而下。可是每次都是失望，伴着抱怨，躲在树荫下，看着天边几小的可笑的卷云飘啊飘啊。。。然后，它就下了。毫无预备的下了。彻彻底底的下了。不可收拾的下了。像一个肾结石的病人做完手术从病房出来，撒的第一泡尿一样，，痛快。我们吓傻了，然后欢呼，然后假装一脸正经的，奔跑起来。把体育老师抛在了一边。一哄而散。 9月中旬的一堂体育课。艳阳高照，但是起了点不小的风。我们早已打消了下大雨的念头，认真的听着唐老师的安排。“唐老师的头发好像是紫色的。”我听到我旁边的同学讲。“哪里，明明是黑的。”另一位同学争辩道。这似乎是很平常的一节体育课，不过凡事要特地提到“平常”的事物多半不平常。“今天天气不错，”唐老师讲。“我们，就，练练500米。”“诶。”我想，这又是一节普通的体育课。不过这样又怎样呢？体育课本来就应当十分正常。我想着。气喘吁吁的我们跑完了第一组，然后就象征性的聊起了天。“你做过楼天成男人必做24题吗。”“没。”“你觉得如何把骗分技巧运用到日常学科中来。”“滚。”“你觉得昨天那道图论的题目能不能用动规做。”“蛤。”“……”“你觉得今天会下雨吗？”“嗯？”好久没听到这么敏感的句子了。同学指了指天空，原来早已变了色。也许刚才在跑步，没注意到。也许是早已麻痹了神经，不在关心。不过我仍不是抱有太大希望。毕竟，有多少次，满天是乌云，天黑的和黄昏一样，却滴点未下，只是带来潮湿的热气罢了。我于是默默的站起来，笑出声来。“爱下不下。”第二组跑完了。面红耳赤的我们终于完成了任务，可以正式自由活动了。我们分散在操场的各个角落，享受着自由的快感，没有人有任何防备。太阳仍然在头顶上，但天黑的很快。忽然，一滴湿湿的东西滴到了我手上。好像是细雨丝，不过很少很少，微不足道，好像并没有引起多少人的注意。可我忽然起了点疑心，赶紧拉上旁边的几个同学往教学楼方向走去。这大概是一种直觉吧。我们操场不算小，就算是跑一时半会也到不了能遮雨的地方，万一下下来，在空荡荡的操场上，可就玩大了。我们半躲在教学楼的玻璃门前，看着操场上嬉笑的同学。初一、初二、初三都有，至少是4,5个班的同学，毫无遮掩的暴露在操场上。事实证明我的抉择是正确的。豆大的，甚至土豆大的雨滴狠狠的砸了下来。从操场的一侧倾覆过来。顿时，场上一片“妈耶”的喊声。所有人，都朝教学楼跑来。而我们几个，就站在里面，像是等着收门票。一秒，绝不大于一秒，像是从水盆里倒出来的一样，剧烈的暴雨就吞噬了整个操场。虽然科学研究表明，在雨量均匀的情况下，不考虑风的影响，同一受雨表面在走路和跑步时所接受到的雨水的量相差不大，但是这个时候没有哪头笨驴会顾得上思考这种东西。操场空了，体育老师也都各回各办公室了。我们终于都平安地回到了教室。我看着湿透了的同学们，忽然有一丝愧疚。但他们似乎很兴奋，为这场突如其来的雨，欢呼起来。不过，就当我们都以为闹剧结束了时，发现班里少了两个人。我们往窗外看去，发现操场上居然还有两个人在并肩悠然散步。我也不好意思骂他们智力障碍了，也许这就是个性，也许这就是最洒脱的友情。 暴雨像开关失调的水龙头一样不断歇地下到隔天早晨，后来才知道是受了强台风山竹的影响。每家每户的窗户前都像水帘洞的瀑布，从“滴滴答答”到“哗哗啦啦”。散去了叫人怀念的热气。金秋已至。。。。。？]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reach-Top] 普及模拟赛反思(模拟/排序/...)]]></title>
    <url>%2F2018%2F09%2F22%2Freach-top-pu-ji-mo-ni-sai-fan-si%2F</url>
    <content type="text"><![CDATA[好吧不得不说这份卷子算完全是信心赛的简单难度，结果我因为怀着检查一下评测机的质量而为Problem-B写了个O3优化而白白丢了一整题的分数，心痛。以后不能再做这种傻事了。题解内容正在撰写中。。。本次测试包含算法：魔改排序，模拟。好吧我故意把暴力漏了。 Problem B水明老师因为视力不好，只能看到长度为2的字符串，例如AB，AA，BA，所以它将长度为2的字符串称为水明字符串，现在小曹老师送了它一个长度为n（由大写英文字母组成）的字符串，水明老师想找到其中出现次数最多的水明字符串BBAABBBA 的答案是BB出现了3次 输入描述 第一行输入n ，2≤n≤100 第二行输入n个字符 输出描述 输出答案 若出现多个解，输出第一个出现的水明字符串 示例数据输入 7ABACABA 输出 AB 解题报告暂空 Problem D水明老师想玩一会儿数字游戏，现在它有一些整数x，并将其写在黑板上，之后对其进行n-1次操作，每次操作有两种方式可选： 1：将x除以3，必须保证x是3的倍数2：将x乘以2 在结束操作之后，水明老师将结果写在黑板上，（原来的那些数字x当然要先被擦掉），那结果将以随机顺序作为你们的输入，即肯定不会和黑板上的顺序一致那你们的任务是将水明老师给你们的数字重新排列之后与黑板上的序列进行匹配，看看能否一致。输出的数列要满足的条件是：第i个数是第i-1个数的两倍或者三分之一（第一个数就随意咯）保证有解且唯一 输入 输入的第一行包含整数n（2≤n≤100） - 序列中元素的数量。输入的第二行包含n个整数a1，a2，…，an（1≤ai≤3*1018） 输出 输出答案 示例数据输入 64 8 6 3 12 9 输出 9 3 6 12 4 8 解题报告第一遍提交，就是没什么技术含量的暴力DFS。每个数都搜索过去，按照题目要求，因为保证有解且只有一个解，所以一旦搜到了答案就直接输出并退出程序。第一次提交用的暴力代码，尝试写出了54分很满意了。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;using namespace std;int n;long long a[110];long long ans[110];bool vis[110]=&#123;false&#125;;stack&lt;int&gt; st;void solution(int x)&#123; if(x==n+1)&#123;// cout&lt;&lt;666&lt;&lt;endl; int flag=0; for(int i=1;i&lt;=n;i++)&#123; ans[++flag]=st.top(); st.pop(); &#125; for(int i=n;i&gt;=1;i--)&#123; cout&lt;&lt;ans[i]&lt;&lt;" "; &#125; exit(0); return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(vis[i])&#123; continue; &#125; if(x==1)&#123; vis[i]=true; st.push(a[i]); solution(2); st.pop(); vis[i]=false; &#125; else&#123; if(a[i]==st.top()*2||a[i]==st.top()/3)&#123; st.push(a[i]); vis[i]=true; solution(x+1); vis[i]=false; st.pop(); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; solution(1);&#125; 成功地骗到了54分，还是十分自豪的，但是和正解的思路完全不同。吊唁正解带节奏。 正解的思路很简单：“第i个数是第i-1个数的两倍或者三分之一”，转换一下就是“第i个数是第i-1个数的两倍，第i-1个数是第i个数的三倍”那么就可以以此作为排序标准。算出每个数中2和3因数的个数，然后2越多排在越后面，3越多排在越前面。于是我们可以得知，只要算出了每个数因数中2，3的个数，那么我们就可以根据其包含因数3的个数减去包含2的因数个数的大小进行排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=110;int n;struct setNum&#123; int index;//当前数字的编号 int rawdata;//当前数字的数值 int p2,p3;//包含2,3的因子数量 int init(int num,int i)&#123; rawdata=num; index=i; int temp=num; p2=p3=0; while(temp%2==0)&#123; temp&gt;&gt;=1; p2++; &#125; while(temp%3==0)&#123; temp/=3; p3++; &#125; //计算包含2,3的因子数量 &#125; friend bool operator &lt; (const setNum cmpnumo,const setNum cmpnum)&#123; if(cmpnumo.p3-cmpnumo.p2!=cmpnum.p3-cmpnum.p2)&#123; return cmpnumo.p3-cmpnumo.p2&gt;cmpnum.p3-cmpnum.p2; &#125; return cmpnumo.index&gt;cmpnum.index; //如果之前的比较结果相同，就按初始顺序排列 &#125; //重定义&lt;，之后排序就可以不再写cmp了&#125;;setNum arr[MAXN];int main()&#123; cin&gt;&gt;n; int temp; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;temp; arr[i].init(temp,i+1); &#125; sort(arr,arr+n); for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;arr[i].rawdata&lt;&lt;" "; &#125;&#125; （持续更新中…）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>排序</tag>
        <tag>题目陷阱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NowCoder] 分则能成(模拟)]]></title>
    <url>%2F2018%2F09%2F22%2Fnowcoder-fen-ze-neng-cheng-1%2F</url>
    <content type="text"><![CDATA[题目描述牛牛刚开始有一个正整数n。每次操作牛牛可以选择一个自己有的数字x，把x分为两正整数y和z，需满足x=y+z，然后获得y×z的收益。（当然，在这个过程中，牛牛会失去x这个数字，并且获得y和z这2个数字。）牛牛一共可以分k次，牛牛希望最大化这k次的收益之和。因为分割的结果y和z是正整数，所以选择的x必须&gt;=2。对于100%的数据，1 &lt;= k &lt; n &lt;= 109对于40%的数据，1 &lt;= k &lt; n &lt;= 10对于70%的数据，1 &lt;= k &lt; n &lt;= 100 输入描述 输入只有一行，包含用空格分开的两个整数，表示n和k。 输出描述 输出一行一个整数，表示答案。 示例数据输入 9 2 输入 27 说明 刚开始牛牛有{9}把9分为3和6，牛牛现在有{6, 3}把6分为3和3，牛牛现在有{3, 3, 3}总收益为63+33 = 27。 解题报告第一次提交，我想都没想就写了个全部平均分1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; vec;int findmax()&#123; int maxn=-1; for(int i=0;i&lt;vec.size();i++)&#123; if(maxn&lt;vec[i])&#123; maxn=vec[i]; &#125; &#125; for(int i=0;i&lt;vec.size();i++)&#123; if(vec[i]==maxn)&#123; vec[i]=0; &#125; &#125; return maxn;&#125;int main()&#123; int tasknum,n; int ans=0; cin&gt;&gt;tasknum&gt;&gt;n; vec.push_back(tasknum); for(int i=0;i&lt;n;i++)&#123; int x=findmax(); int y,z; if(x%2==0)&#123; y=z=x/2; &#125; else&#123; y=x/2+1; z=x/2; &#125; cout&lt;&lt;y&lt;&lt;","&lt;&lt;z&lt;&lt;endl; ans+=y*z; vec.push_back(y); vec.push_back(z); &#125; cout&lt;&lt;ans;&#125; （持续更新中…）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[体育课日志] 摔了个大跤 9.4-9.19]]></title>
    <url>%2F2018%2F09%2F20%2Fshuai-liao-ge-da-jiao-you-gan-hou-ji%2F</url>
    <content type="text"><![CDATA[2018年的九月份里的一天，本该是开学初美好的日子。这天体育课上来了一位新的体育老师，我远瞅他一脸黑线，心里忽然有点失望，初一时那个乐呵呵的老楼不教我们班了，换了一个外表目前看来不大友好的老师。那位老师走近了，我才发现他似乎有点帅。头发染了一点淡淡的紫色，戴着方框细边的眼镜，不大的眼睛上是模糊的双眼皮。棱角分明的下巴，还有一点凌乱的胡髭，散发着男人的气息。“上课铃响了没！？”他冲着散漫的学生们吼道。声音也那么富有磁性。我想着，急忙跑来立定。“三班的学生，我带了一年了”他顿了顿，“四班的新同学们，这个学期也由我来教。我姓唐，就叫我唐老师。”话音刚落，我们就用力鼓掌，“唐老师好！”“唐老师辛苦了！”…… “我的要求很简单。”唐老师挥挥手示意我们安静，然后用高亢些的声音说道，“不吵不闹，听指挥行事，有什么特殊原因的必须打报告。”唐老师清了清嗓子，“另外，体育课上受了点皮外小伤，别像个娘们儿一样的哇哇叫，给我看过，然后自己去医务室治疗。”三班的同学听着，开始不耐烦的窃窃私语起来。唐老师看着他们，眼睛睁大了点，轻轻地但十分具有杀伤力的说了句“怎么的啊，想给四班同学示范一下违反纪律的后果啊。”三班的同学半怂半滑稽地应着“不不不不……”唐老师皎洁地笑了笑，“不违反纪律，那就得听我指令行事，给你们普及了一个学年还搞不灵清吗？”“听指令，我们听，我们听”三班的同学半嘲弄地应道。“好，那么三班听令，向右转！5圈不中断，跑步走！”语毕，唐老师转过身来对着我们皎洁地笑着，“以后别学他们这样啊” 大概是三班那群可怜的同学跑到第三圈时，老师让我们跟在他们后面慢跑两圈。我看着天空，静静地想着“昨天未调完的题”。忽然地、毫无预兆地，我的左脚踩到了我的右脚后跟，然后一个重心不稳，左腿蹭着地滑了出去。 我侧着身子转过来，抓住不知道谁伸过来的手，紧紧握住，站了起来。我活动了一下，没有感到什么不适，但我不敢看我着地的那条腿的膝盖，我想肯定已经磨掉了一层皮。但我想了想，“一点点小小的皮外伤”，我怎么能“像个娘们儿”一样的就脱离队伍。我于是向前加速跑去追上了排头，直至跑完两圈，我才怯怯地找到唐老师。果然这满是血斑的伤口让唐老师难以拒绝我去医务室的请求。学校最近搞好在搞装修，医务室不知道换到哪里了。我就拖着一条腿在学校里痛苦的走来走去。最后在一位不肯透露姓名的好心人的帮助下，我找到了隐藏在图书室深处的学校医务室。我找到医师，坐下来，懊悔着自己的大滑之稽。医师拿着消毒棉签，蘸上满满的“聚维酮碘溶液”（我这一年都不会忘掉这个令人痛苦的名字），然后在我的伤口上涂抹起来。涂了一遍，似乎不够；再涂一遍，依然不够干净……医师仔仔细细的给我涂了好几个来回，终于肯放我走了。而我终于可以走出图书室，放下捂着嘴的手，大声地、痛苦地叫了起来。 开始的几天非常疼。可怜的我每天晚上都抱着腿，看它有没有结出些疤来。第一天，腿上涂过的“聚维酮碘溶液”在伤口上凝聚起来，像一个个水疱一样，十分狰狞。我一个劲的祈祷，就差每天晚上读一读《圣经》了。毕竟拖这样腿上学实在难受，而且十分的不雅观，影响市容。每天上下楼是最大的挑战，我只得尽量让受伤较严重的左腿保持不动，然后全凭右腿和手臂的力量向上爬（左手使不上劲）。后来疤刚结出来的时候我作死的双脚走了上楼，结果疤上又留了个不小的口子。大课间算是绝缘了，在别人都下楼跑步的时候，我就躲在小教室（我们学校每个班都有大小教室）或是办公室里帮老师打杂。体育课老师给我们订了严格的请假规则，必须是家长、班主任签字才有效。不过我这么大个口子的威慑力远比那一张请假单大多了。我想了想，全局变量初始值默认为0，考试的时候不还都会加个手动赋值0吗。于是，为了以防老师旧的我的伤口是化妆上去的，我还是严谨的开了个单子。过了1周，伤口终于有了痊愈的趋势。我兴高采烈，到操场上跑了5圈慢跑，做了几组引体向上，回家洗了个香香澡，穿上洗白白的衣服。第二天，伤口就化脓了。我不停的往伤口涂那个“聚维酮碘溶液”，希望能脓能快点消掉。本就丑陋的伤口上多了一粒白白的、粘稠的脓，还不时地往外分泌些粘稠的液体，实在让人不爽，甚至无地自容。又过了一天脓就彻底消失了，留下了一个小小的坑。去医务室复查了下，医生叫我以后要矜持一点，我十分认真的答应的。过了约莫2~3天，疤开始掉落。最外层的一圈开始松动。欣喜若狂的我把医生的“矜持一点”的劝告抛在脑后开始挖疤，并乐此不疲。大概是伤口好之前的倒数第4天，我判断失误，把一块没完全痊愈的疤撕了下来。等我惨叫完后，我仔细思考了一下，然后换了个方向接着挖。大概是受伤之后的第二周的最后几天，伤口已经基本痊愈了，只留下几块层次不齐的小的、棕色的厚厚的疤。第三周，伤口已经完全痊愈了，但是留下了一块肤色与周围黝黑的皮肤明显不同的印记。白白的一块，里面有些黑色的斑点。又一次我突发奇想看能不能洗掉它，结果失败了，但我不事后死活承认自己脑子有问题。至此，以闹剧开场的事故平淡的结束了，但是旷了五六节体育课的我得孤身一人去补考1000米，50米，立定跳远和其他。。。 开学初就摔跤受伤，流了些血，这算“开门红”吗？如果是这样的话，，保佑我今年NOIP初赛能上分数线。。。如果可以的话我可以多摔几次。 另：伤口好了之后好久我才又洗了一次香香澡，穿上洗白白的衣服。。。然后一周里都在检查原先破皮的地方有没有发出脓包来。。。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人只不过是一根芦苇]]></title>
    <url>%2F2018%2F09%2F02%2Fren-zhi-bu-guo-shi-yi-gen-lu-wei%2F</url>
    <content type="text"><![CDATA[人只不过是一根苇草，是自然界最脆弱的东西；但他是一根能思想的苇草。用不着整个宇宙都拿起武器来才能毁灭；一口气、一滴水就足以致他死命了。然而，纵使宇宙毁灭了他，人却仍然要比致他于死命的东西更高贵得多；因为他知道自己要死亡，以及宇宙对他所具有的优势，而宇宙对此却是一无所知。 因而，我们全部的尊严就在于思想。正是由于它而不是由于我们所无法填充的空间和时间我们才必须提高自己。因此，我们要努力好好地思想；这就是道德的原则。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线段树]]></title>
    <url>%2F2018%2F08%2F04%2Fshu-ju-jie-gou-xian-duan-shu%2F</url>
    <content type="text"><![CDATA[概述线段树可以以极高的效率查询一个区间内动态的数据的总和（没错说的很平淡）。简单的说就是给你一组数据，然后问题是求第i个数据到第j个数据之间所有数据值得总和是多少。当然，这些数据不是一成不变的（这就是线段树和树状数组的区别）。事实上，在学习了树状数组之后再来学习线段树的效果会更好。事实上它们是连贯的知识，只是被贴上了不同的标签，以至于看起来它们分道扬镳。当然，如果学习完了线段树，有一句忠告不能忘：能用树状数组就不要用线段树，要不然万一跪了吃亏的是自己。 线段树基础概念 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为$O(logN)$。而未优化的空间复杂度为$2N$，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。——著名权威学者 百度词条 我引用了百度词条的这样一句话，似乎有点难懂。我尝试性的解说一下：线段树是建立在线段基础之上的二叉树，并且除了叶子节点以外，其它的节点的值为其左儿子与右儿子的值之和。 解析我们可以通过构造一棵树（也就是尝试画一棵线段树），来更为直观的感受线段树其中的含义。第一步，线段树是建立在线段上的（可以理解为建立在线性数据上），那么我们就先画一个数组（就是一种常用的线性数据），我们先不管它上面会长成什么模样。当然了，因为前面提到树状数组是求一个区间内的数据总和，所以我们标记一下每个点代表的区间。因为现在都是叶子节点（它们没有儿子！），所以当前每个点所代表的区间就是它自己到它自己。接下来，我们会以一种很容易理解的方式，找到这些叶子节点的爸爸。在线段树中，我们可以这样理解：每两个儿子共有一个爸爸（滑稽），并且这个爸爸的值就是两个儿子的值之和，于是就能很轻松的往上推一层。接下来如上分析，再找爸爸的爸爸。 这边要注意一点，必须是两个儿子才能配对一个爸爸。接着找爸爸（一脸滑稽）。一般一只找到再也配对不出爸爸的时候算构建完成。至此，爸爸都找完了，您也就构造好了一棵线段树。 所以我们可以总结一下，构造线段树的构成可以理解为找爸爸（其实应该是创造爸爸，因为本身没有爸爸的） 线段树模板线段树的模板是很常用的，但是一般不建议魔改（容易写跪）。线段树的模板主要包含三个函数（如果要做到区间修改的话可能需要多些一个），在正常12345#if 0声明#endifconst MAXN=100100;int rowData[MAXN]=&#123;0&#125;; 定义结构体Node$Segtree$中的每一个节点Node都需要包含：左边界（l:left），右边界（r:rigth）以及这一区间内的总和（data）。1234struct Node&#123; int l,r; long long data;&#125;segtree[MAXN&lt;&lt;2]; 构造函数Build在使用线段树直线，必须先得构造出线段树的模型。12345678910111213void Build(int i,int l,int r)&#123; segtree[i].l=l; segtree[i].r=r; if(l==r)&#123; segtree[i].data=rawData[i]; return; &#125; int mid=(l+r)&gt;&gt;1; Build(i&lt;&lt;1,l,mid); Build(i&lt;&lt;1|1,mid+1,r); segtree[i].data=segtree[i&lt;&lt;1].data+segtree[i&lt;&lt;1|1].data; return;&#125; （持续更新中…）（好吧我想颓了）（逃]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论-从七桥问题到欧拉路]]></title>
    <url>%2F2018%2F07%2F17%2Ftu-lun-cong-qi-qiao-wen-ti-dao-ou-la-lu%2F</url>
    <content type="text"><![CDATA[思考 小明比小华高，小华比小红高，于是我们就能很轻松的判断出小明比小红高。可是，如何让计算机处理这样的信息呢？这个时候，我们引进了&lt;图&gt;的概念。 对于一组有关联的数据如A&gt;B ,B&gt;C，我们的大脑可以很轻松的处理并整合这些信息，但是计算机并不能直接地判断出A与C的关系，此时就需要图的帮助。图论的确是一种十分有趣的算法，它能形象地将某种复杂的关系清晰地表现在计算机中。构造了图，可以结合其它有趣的算法，如BFS/DFS来遍历图从而获取图中的信息。 七桥问题起源 18世纪，在哥尼斯堡的一个公园里，有七座桥将普雷格尔河中两个岛及岛与河岸连接起来。问是否可能从这四块陆地中任一块出发，恰好通过每座桥一次，再回到起点？欧拉于1736年研究并解决了此问题，他把问题归结为如右图的“一笔画”问题，证明上述走法是不可能的。 七桥问题是图论中最重要的内容之一， 它最终是无解的，但是由此引发了大量的数学家的思考，推断和验证。数学家们把该问题简化为了一笔画问题，最后得出的结论是：连通图可以一笔画的充要条件是：奇点的数目不是0个就是2个（连到一点的数目如是奇数条，就称为奇点，如果是偶数条就称为偶点，要想一笔画成，必须中间点均是偶点，也就是有来路必有另一条去路，奇点只可能在两端，因此任何图能一笔画成，奇点要么没有要么在两端） 推广而计算机科学诞生之后，我们又一次的对原先的结论进行推广。首先我们规范了在图论中这些规律、事实的名称。 名称定义欧拉路如果一个图存在一笔画，则一笔画路径称为欧拉路欧拉回路在欧拉路的基础上，如果起点和终点相同，则称该欧拉路为欧拉回路奇点跟这个点相连的边数目有奇数个的点 对于能够一笔画的图，我们有以下两个定理： 【定理一】存在欧拉路的条件：图是连通的，有且只有2个奇点 【定理二】存在欧拉回路的条件：图是连通的，有且只有0个奇点 求欧拉路/欧拉回路算法一般的，我们会用DFS深度优先搜索来求某个图中的欧拉路/欧拉回路，这是最简单同时最容易理解的求法之一。根据前面一笔画得出的定理，当我们需要寻找某个图中的欧拉路或欧拉回路时，先得寻找到图中的奇点，然后对其中从其中任意一个奇点开始DFS搜索，如果没有找到奇点，则从任意一点开始DFS即可。这样做的时间复杂度为$ O(M+N) $（其中$M$为边数，$N$为点数），这个时间复杂度稍微玄学了一点，不必计较。我们来举一道题目： 求欧拉路/欧拉回路例题给定一张图，寻找出其中的欧拉路或欧拉回路。给定的图保证有欧拉路/欧拉回路 输入格式第一行输入n,m，表示有n个点，m条边，一下m行描述每条边连接的两点，每行输入x,y表示x,y相连。 输出格式按顺序输出欧拉路或欧拉回路的路径，每个点中间空一格。如果有多条路径，允许输出任意一条。 输入样例与输出样例输入样例1234565 5 1 22 33 44 55 1 输出样例11 5 4 3 2 1 数组解法ARRAY CODE我们来贴一个数组代码理解一下。我们构建一个二维数组map[n][n]来表示每个节点之间的关系。初始化map全部为false，如果$i$节点与$j$节点相连，那么map[i][j]=true。同时还需要记录每个节点的度（与这个点相连的边有几条，也就相当于与该点相连的点有几条）。 重要变量变量名称变量意义int n总共有n个点int m总共有m条边int beg欧拉路/欧拉回路的起点int map[n][n]记录哪些结点是相连的int cntroad[n]记录每个点的度数int vis[n]记录该点是否走过int reroad[n]记录最终的欧拉路/欧拉回路所经历的点int cntreroad记录当前欧拉路中点的个数 构造图1234567891011memset(map,0,sizeof(map));//如果是全局变量会自动清0，可省略cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; g[x][y]=g[y][x]=1;//记录这两个点是相连的 cntroad[x]++; cntroad[y]++; //这两个点的度数增加1&#125; 找到欧拉路/欧拉回路的起点根据前面七桥问题得出的结论：如果一张图中有且仅有两个奇点，那么该图必定包含欧拉路，且两个奇点一个是起点，一个是终点。如果该图没有奇点，就说明该图包含欧拉回路，从任意一点出发都可以走回原点。于是可得一下代码来寻找欧拉路/欧拉回路的起点12345678910beg=1;for(int i=1;i&lt;=n;i++) if(cntroad[i]%2==1)//找到奇点，即为起点 beg=i;/*break; 找到了就可以退出， 因为两个奇点中可以任选一个作为起点*//*如果此时没有找到一个奇点，说明这张图里包含的是欧拉回路，那么beg就是初始定义的1（其实随便从哪一点开始找都可以）*/ DFS寻找欧拉路/欧拉回路搜索，把每一个点的子节点都列出来，找到路径。要注意的是同一条边走过了就应该记录一下，下一次不能再走，不然会陷入死循环，一直在两个点之间徘徊。有以下两种写法123456789101112void find(int x)&#123; for(int i=1;i&lt;=n;i++) if(map[x][i]==1) &#123; map[x][i]=map[i][x]=0; /*相当于删除了这条边 下一次搜索就不会再走了*/ find(i); &#125; reroad[++cntreroad]=x;&#125; 123456789101112void find(int x)&#123; for(int i=1;i&lt;=n;i++) if(map[x][i]==1 &amp;&amp; vis[i]==0) &#123; vis[i]=1; /*记录一下已经走过了这个点， 下一次就不会再走*/ find(i); &#125; reroad[++cntreroad]=x;&#125; $\color{red} {注意}$！第二种方式仅限于计算欧拉路，一旦遇到欧拉回路就会出错理解一下：第二种方法在每个点走过之后就会标记：这个点不能再走了，但是欧拉回路的起点和终点是一样的，也就说名起点必定要走两次，于是我们可以纠正一下，改成：1234567891011void find(int x)&#123; for(int i=1;i&lt;=n;i++) if(map[x][i]==1 &amp;&amp; (vis[i]==0 || i==beg)) //满足一个即可 &#123; vis[i]=1; find(i); &#125; reroad[++cntreroad]=x;&#125; 输出欧拉路不必多说 12for(int i=1;i&lt;=cntreroad;i++) cout&lt;&lt;reroad[i]&lt;&lt;" "; 向量解法VECTOR CODE相比之下，$vector$向量的解法逼格会高很多。对于学过向量的同学来说，$vector$的解法会方便很多。但是对于没学过的同学，会略微有点难以理解。$vector$解法不用记录每个点度数和最终欧拉路的点数，因为可以直接用.size()得到当前vector中有多少个数。简单的讲一下吧： 重要变量变量名称变量意义int n总共有n个点int m总共有m条边int beg欧拉路/欧拉回路的起点vector&lt;int&gt; map[n]记录哪些结点是相连的int vis[n]记录该点是否走过vector&lt;int&gt; reroad记录最终的欧拉路/欧拉回路所经历的点 构造图在求欧拉路/欧拉回路的过程中，我们就不过多的纠结什么有向还是无向了，我们只要记录哪些点是相连的就足够了。 123456789cin&gt;&gt;n&gt;&gt;m;int ir,it;for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;ir&gt;&gt;it; map[ir].push_back(it);//STL大法好 map[it].push_back(ir);//STL大法好*2 //双向路&#125; 找到欧拉路/欧拉回路的起点与数组解法同理，如果一张图中有且仅有两个奇点，那么该图必定包含欧拉路，且两个奇点一个是起点，一个是终点。如果该图没有奇点，就说明该图包含欧拉回路，从任意一点出发都可以走回原点。这个时候我们可以调用$vector$的.size()函数来统计某个点的度数了。因为在.push_back()的时候$vector$会帮你进行size++的操作。1234beg=1;for(int i=1;i&lt;=n;i++) if(vector[i].size()%2==1)//STL大法好*3 beg=i; DFS寻找欧拉路/欧拉回路搜索，把每一个点的子节点都列出来，找到路径。要注意的是同一条边走过了就应该记录一下，下一次不能再走，不然会陷入死循环，一直在两个点之间徘徊。有以下两种写法 12345678910void find(int x)&#123; for(int i=1;i&lt;=n;i++) if(map[x][i]==1) &#123; map[x][i]=map[i][x]=0; find(i); &#125; reroad.push_back(x);//STL大法好*4&#125; 输出欧拉路不必多说 12for(int i=1;i&lt;=reroad.size()/*STL大法好*5*/;i++) cout&lt;&lt;reroad[i]&lt;&lt;" "; 总结图论，数论是OI学习发育的重要关卡，十分的有意思，但是也必须静下心来琢磨，反复思考才能获取最好的学习效果。用代码构建的图看不见，摸不着，点点线线远没有真实的图画美丽，但是它们构建出的思想，十分让人着迷。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Rewrite] 洛谷博客上的存档(桶排序/Stack/模拟/打表)]]></title>
    <url>%2F2018%2F07%2F01%2Frewrite-luo-gu-bo-ke-shang-de-cun-dang%2F</url>
    <content type="text"><![CDATA[题解 P1554 【梦中的统计】看了这么多大佬的代码之后我实在忍不住了，决定站出来给各位同学讲一讲一种可以稍微提升逼格的做法(大佬们可以自顾自跳过了)，这道题其实就是桶排序，用一个数组比如Count[10]来登记0~9每个数字出现的个数。在这边为了看起来比较美观，可以用函数来写。函数是C++中比较重要的东西了，我们写的int main()或int WINAPI WinMain()其实就是一个函数，我们的程序一般习惯先运行main()函数。我们也可以自己来写一个函数，函数的用法详见：【菜鸟教程】C++函数教程。这里我们可以写一个CntPlus函数，把每一个数中0~9的个数都放到一个专门的数组里就可以了，所以和桶排序是密不可分的，关于桶排序的用法详见：C++桶排序教程（该文章出处：https://blog.csdn.net/u010884939/article/details/40709039）。 函数体我个人是这样来构造函数的：123456789101112131415void CntPlus(int Num,int Cnt[10])&#123; while(Num!=0) &#123; Cnt[Num%10]++;//体现桶排序的关键语句 Num/=10; /* *以上这种算法在提取一个数的每一位时 *经常用到，用while循环反复对Num进行 *Num/=10,Num%10的处理，就可以提取出 *数的每一位，%是求余，/是整除，同学 *不理解的话可以自己手算一下。 */ &#125;&#125; 题解源码好了，既然有了函数，就可以用了。在主函数中，从n到m循环，然后对每一个数都进行此操作，整个算法就变得十分简单轻松愉快了。最后代码奉上：1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;void CntPlus(int Num,int Cnt[10])&#123; while(Num!=0) &#123; Cnt[Num%10]++; Num/=10; &#125;&#125;int main()&#123; int n,m; int Cnt[10]=&#123;0&#125;;//数组清零 cin&gt;&gt;n&gt;&gt;m; for(int i=n;i&lt;=m;i++) CntPlus(i,Cnt);//对该区间每个数都进行操作 for(int i=0;i&lt;=9;i++) cout&lt;&lt;Cnt[i]&lt;&lt;" ";//直接输出&#125; 题解 P1469 【找筷子】【STL大发好】栈解法看到这道水题我第一眼就想到了栈，可惜还是需要用到排序，纯栈的话会很难也有可能是我太蒻了 简单讲一下思路 输入 排序 边入栈边去重 输出 提交等待AC 关于栈 一个大佬写的栈的教程 Code123456789101112131415161718192021222324252627#include&lt;iostream&gt;//C++标准输入输出流#include&lt;algorithm&gt;//算法库，包含排序函数#include&lt;stack&gt;//STL大法之栈的专用库using namespace std;int main()&#123; stack&lt;int&gt;st;//创建栈st int n;//有n只筷子 cin&gt;&gt;n;//读入n int kuaizi[n];//每个筷子的长度 for(int i=0;i&lt;n;i++) cin&gt;&gt;kuaizi[i];//读入每个筷子的长度 sort(kuaizi,kuaizi+n);//排序 for(int i=0;i&lt;n;i++) &#123; if(i==0)//如果是第一只筷子就直接入栈 st.push(kuaizi[i]); else &#123; if(!st.empty() &amp;&amp; kuaizi[i]==st.top()) st.pop();//匹配到相同筷子，就出栈 else st.push(kuaizi[i]);//没找到就先入栈 &#125; &#125; cout&lt;&lt;st.top();//没被匹配到的筷子就会被留在栈顶&#125; 题解 P1319 【压缩技术】这样一道入门题目，本来可以用for循环直接操作，但作者异想天开(xian de dan teng)地把所有数据登记在一个数组里面，然后再统一按格式输出。也就是定义一个数组Map，大小为n成n，然后按照输入数据，把Map中每一个点改为0或者是1，然后根据题目要求的格式输出。比较简单，就直接贴代码了。 代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;//事实上没有用using namespace std;int main()&#123; int n; cin&gt;&gt;n; //矩阵长宽 int Map[n*n+10]; //设置一个登记用的数组，其实n*n就够了，+10是为了防爆 int Full;//输入要用的 bool Key=false; //判断当前输入的是1的数量还是0的数量，初始为0 int p=0; //已经登记到第几个数，类似于指针 while(cin&gt;&gt;Full)//持续输入 &#123; int i; for(i=p;i&lt;p+Full;i++) Map[i]=Key;//把这一块区域登记为Key，就是0或1 p=i; Key=!Key; //本文唯一难点， /* *“!”表示相反， *如果原先为true就变为false *如果原先为false就变为true *这里就把“0和1的数量交替输入”体现出来了 */ &#125; p=0; //指针归零，下面要开始从头开始输入 for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; cout&lt;&lt;Map[p]; p++; //输出 &#125; cout&lt;&lt;endl; /*按格式输出*/ &#125; &#125; 知识点1Key=!Key 这是C++中独有的运算符，C++党们注意了，这是本文中唯一的高逼格用法了，“!”的作用就在于可以翻转原先数据的值，真变为假，假变为真。而C++中非0即为真，这样在程序中就把“其余各位表示交替表示0和1 的个数”体现的淋漓尽致(he he he he)了。 题解 P1603 【斯诺登的密码】我个人认为这道题的重点在于打表，所以这边就教大家（大佬们可以跳过了）一个打表高颜值的打表方式：struct(结构体)。 结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。一般我们会这样声明：1struct Box; 在C语言中则一般是：1typedef struct Box; 然后你可以往里面放东西，比如：123456789struct Student&#123; int num; //声明一个整形变量num char name[20]; //声明一个字符型数组name char sex; //声明一个字符型变量sex int age; //声明一个整形变量age float score; //声明一个单精度型变量 char addr[30]; //声明一个字符型数组addr &#125;; 建立好结构体了，就要试着用你的结构体定义，像这样：1Student XiaoMin; 此时就定义了一个结构体变量：XiaoMin。如果你需要调用其中的的某个值得话，可以像这样操作：12XiaoMin.name="XiaoMin";XiaoMin.score=13.5; 或者这样：1XiaoMin=&#123;13,"XiaoMin",'M',14,13.5,"hello"&#125;; 接下来请各位同学打开C++手打一遍自行领会。 更多关于Struct的知识可以学习：C++Struct 如何打表讲了struct，就可以来进行高级打表了，首先建立一个结构体：12345struct Table&#123; string Word;//单词内容 int value;//该单词的值&#125;; 然后定义一个表：1Table Key[40]; 然后就要使用你灵敏的小手指……12345678910111213Key[40]=&#123; &#123;"one",1&#125;,&#123;"two",2&#125;,&#123;"three",3&#125;, &#123;"four",4&#125;,&#123;"five",5&#125;,&#123;"six",6&#125;, &#123;"seven",7&#125;,&#123;"eight",8&#125;,&#123;"nine",9&#125;, &#123;"ten",10&#125;,&#123;"eleven",11&#125;,&#123;"twelve",12&#125;, &#123;"thirteen",13&#125;,&#123;"fourteen",14&#125;,&#123;"fifteen",15&#125;, &#123;"sixteen",16&#125;,&#123;"seventeen",17&#125;,&#123;"eighteen",18&#125;, &#123;"nineteen",19&#125;,&#123;"tewnty",12&#125;, //此上为正规部分 &#123;"a",1&#125;,&#123;"both",2&#125;,&#123;"another",1&#125;, &#123;"first",1&#125;,&#123;"second",2&#125;,&#123;"third",3&#125; //此上为非正规部分&#125;; 如何查找打完表之后，每输入一个单词，就对这个单词进行搜索，搜到的话，就按题目要求进行计算，否则可以直接跳过接下来的步骤。在这里作者采用的是普通(ruo zhi)的遍历查找，如下：1234567891011121314151617bool SearchRight=false;cin&gt;&gt;Full;int j=-1;do//在范围内查找该单词&#123; j++; if(Full==Key[j].Word)//如果查找到了 &#123; SearchRight=true;//,登记查找到了 break; &#125;&#125;while(j&lt;26);//在规定范围内查找if(!SearchRight)/* *如果未查找到， *效果与 if(SearchRight==false) 相同*/ continue;//直接返回，输入下一个单词 接下来的操作相信大家都是没有困难的了。那么最后源码给上。 题解源码（抄袭者后果自负）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct Table;//简单的建立一个结构体用来将单词与值对应//C++中 typedef struct可以简写为 structstruct Table&#123; string Word;//单词内容 int value;//该单词的值&#125;Key[40]=&#123; &#123;"one",1&#125;,&#123;"two",2&#125;,&#123;"three",3&#125;, &#123;"four",4&#125;,&#123;"five",5&#125;,&#123;"six",6&#125;, &#123;"seven",7&#125;,&#123;"eight",8&#125;,&#123;"nine",9&#125;, &#123;"ten",10&#125;,&#123;"eleven",11&#125;,&#123;"twelve",12&#125;, &#123;"thirteen",13&#125;,&#123;"fourteen",14&#125;,&#123;"fifteen",15&#125;, &#123;"sixteen",16&#125;,&#123;"seventeen",17&#125;,&#123;"eighteen",18&#125;, &#123;"nineteen",19&#125;,&#123;"tewnty",12&#125;, //此上为正规部分 &#123;"a",1&#125;,&#123;"both",2&#125;,&#123;"another",1&#125;, &#123;"first",1&#125;,&#123;"second",2&#125;,&#123;"third",3&#125; //此上为非正规部分&#125;;//简单的打表int main()&#123; string Full; bool FirstPrint=true;//登记是否是第一次输出 bool SearchRight=false;//登记是否查找到 for(int i=0;i&lt;7;i++) &#123; SearchRight=false;//初始设置为未查找到 cin&gt;&gt;Full; int j=-1; do//在范围内查找该单词 &#123; j++; if(Full==Key[j].Word)//如果查找到了 &#123; SearchRight=true;//登记查找到了 break; &#125; &#125;while(j&lt;26);//在规定范围内查找 if(!SearchRight) continue;//直接返回，输入下一个单词 int PrintAns=(Key[j].value*Key[j].value)%100; if(FirstPrint)//效果等同于 if(FirstPrint==true) &#123; /*检测是否是第一次输出，如果是的话，就不保留前导0*/ printf("%d",PrintAns); FirstPrint=false;//登记，第一次输出结束 &#125; else printf("%02d",PrintAns);//保留前导0 &#125; if(FirstPrint) /*因为凡是输出过的都会登记FirstPrint为false， *所以如果FirstPrint为真(true) *就说明此时还没有输出 *根据题目要求，要输出0*/ cout&lt;&lt;0; return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>归档</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>桶排序</tag>
        <tag>Stack</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2050云栖大会游记]]></title>
    <url>%2F2018%2F05%2F26%2F2050-yun-qi-da-hui-you-ji%2F</url>
    <content type="text"><![CDATA[启程2050-ACMer Reunion复播 2018年5月25日周五12点30分，大巴从学校出发。期待了好长时间的云栖2050总算是不远了。我坐在车上，激动地望向车外，努力的想象云栖小镇的样子，激动地把安全带拔开又系上，系上又拔开。不到1个小时的车程，我们就到达了目的地。大朵大朵的灰云含着雨，铺满天空，阳光依旧从间隙中撒下。我在柜台拿到了自己的【参会者通行证】，激动地跑过安检门。我第一眼看到就2050的标志伫立在云栖小镇的前方。我激动地拉上队长的手，跑向了ACMer大赛的检录处，拿上了我们队每个人的参赛牌。赛场上空调打的很足，好像喷了些干冰，聚光灯前烟雾缭绕，深吸一口能感受到饱满的蒸馏的味道。左侧的柜台能领取2050ACMer的纪念服，我取来就直接套在身上。比赛还没有开始，我于是开始满赛场跑，在舞台下方偷看主持人，与食物补给处的管理员小哥拍合影，和后排的大佬打招呼，和记者同志聊天，找摄像师给我们队拍特显……一直持续到比赛开始，我都死活不肯消停。 赛事主持人上台，用一种引人注目的声音宣布了比赛开始。于是我们一桌——三个人，把手放在一起，激动地喊：“2050ACMer-AU，必胜！”我们于是开始揣摩这些纯英文的题目，试图寻找到最水的题目先下手。挣扎了20分钟左右，志愿者把一束粉红的气球粘到邻桌的wxw大佬的桌上。我们于是开始紧张了——他们做出来了一题，而我们却空空如也。50分钟左右，在经过不下4次的失败后，我们终于AC了一道题——也就是那道所谓的保分题——但我们依旧抑制不住激动地心情，抽搐般地鼓起掌来，十分宏亮，难以停息——直到我们发觉领桌的选手和主持人都投来了惊吓的眼神。获得了一题AC的动力，我们更加激情澎湃。可惜再多的激情也弥补不了技术上的缺陷。到比赛结束，我们的桌上也仅有一只气球孤零零的飘摇。不过我们都十分满足了。我把气球解下来，系在脖子上，绕着赛场跑了一圈。忽然，在场的人都开始奋力鼓掌。我回头一瞅——唐文斌大佬！我期待了好长时间能够看到真人的大佬终于露脸了！我激动地蹦跳着回到位子上。那个胖胖的主持人宣布让唐文斌大佬进行赛后题目答疑。“这道题就是非常简单的动态规划……”“这道题只有转成9进制就能轻松解出….”“这道题归并排序一下就好了……”“这道题很简单，模拟一下嘛……”“……”我们一群小初一听得云里雾里，但眼神中无不透露出崇拜之情。这些我们三个小时都折腾不出来的题目，他一挥手，摸一把键盘，似乎连脑筋都不用转地就解出来了。比赛结束了，带队的金老师赶紧让我们排好队伍，然后好不容易说服了唐文斌过来和我们合影。我们各自拿上了印有“CE”“这题他们肯定是暴力过的”的牌子，举在头顶或是摆在下巴下，然后紧紧地靠向唐文斌老师，摄像师喊“1,2,3”，我们喊“AU！”。我十分幸运的争取到了和唐老师单组合影的机会，我于是死死地往唐老师靠。这种感觉真是太美妙了，我甚至闻到了唐老师身上机房的味道，激动地不得了。 思索老师宣布启程返校，我于是意犹未尽地解开脖子上的绳子，然后看着它飞起来。天已经十分黑了——我们出来约莫是8点左右，这时候云已经散了，马路上只有极少的几个人匆匆走过。我再次望向云栖小镇，望向“2050”的巨大的标志。我的心中忽然涌动起一种强烈的感觉——如果有机会，我一定要成为这样的活动的召集者。我还算不上是一名合格的OIer或是ACMer，但是这次比赛给了我一种强烈的使命感——和这样一群志同道合的小伙伴们一同学习竞争实在是太令人心潮澎湃了。我甚至可以称之为幸福。我喜欢这种感觉，我喜欢指尖敲击键盘时美妙的“嗒嗒”声，我喜欢在每一行代码中寻找错误的过程，我喜欢摁下F9编译时的紧张，我喜欢调试时的激动，我喜欢看到ACM竞赛红色的AC，NOI蓝色的AC，还有许多OJ的绿色的AC……这是我的梦想，我一定要实现它——这种感觉比以往任何一个时候都要强烈的多。我希望将来的我，能以一个OIer或是ACMer的身份再来回看这篇文章——然后笑出声来。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
